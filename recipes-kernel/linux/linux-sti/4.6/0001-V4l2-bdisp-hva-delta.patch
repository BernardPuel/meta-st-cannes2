From de69d599d53f089fabbb56da47a8d8b4e55e1a61 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@st.com>
Date: Fri, 22 Jul 2016 14:11:34 +0200
Subject: [PATCH 01/12] V4l2: bdisp, hva, delta

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@st.com>
---
 .../devicetree/bindings/media/st,sti-hva.txt       |   24 +
 drivers/media/platform/Kconfig                     |   39 +
 drivers/media/platform/Makefile                    |    3 +
 drivers/media/platform/sti/bdisp/bdisp-v4l2.c      |    3 +
 drivers/media/platform/sti/delta/Makefile          |    6 +
 drivers/media/platform/sti/delta/delta-cfg.h       |   60 +
 drivers/media/platform/sti/delta/delta-debug.c     |  123 ++
 drivers/media/platform/sti/delta/delta-debug.h     |   16 +
 drivers/media/platform/sti/delta/delta-ipc.c       |  589 +++++++
 drivers/media/platform/sti/delta/delta-ipc.h       |   76 +
 drivers/media/platform/sti/delta/delta-mem.c       |   57 +
 drivers/media/platform/sti/delta/delta-mem.h       |   16 +
 drivers/media/platform/sti/delta/delta-mjpeg-dec.c |  468 +++++
 drivers/media/platform/sti/delta/delta-mjpeg-fw.h  |  221 +++
 drivers/media/platform/sti/delta/delta-mjpeg-hdr.c |  213 +++
 drivers/media/platform/sti/delta/delta-mjpeg.h     |   63 +
 drivers/media/platform/sti/delta/delta-v4l2.c      | 1838 ++++++++++++++++++++
 drivers/media/platform/sti/delta/delta.h           |  502 ++++++
 drivers/media/platform/sti/hva/Makefile            |    2 +
 drivers/media/platform/sti/hva/hva-h264.c          | 1096 ++++++++++++
 drivers/media/platform/sti/hva/hva-hw.c            |  511 ++++++
 drivers/media/platform/sti/hva/hva-hw.h            |   73 +
 drivers/media/platform/sti/hva/hva-mem.c           |   63 +
 drivers/media/platform/sti/hva/hva-mem.h           |   19 +
 drivers/media/platform/sti/hva/hva-v4l2.c          | 1610 +++++++++++++++++
 drivers/media/platform/sti/hva/hva.h               |  454 +++++
 26 files changed, 8145 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/media/st,sti-hva.txt
 create mode 100644 drivers/media/platform/sti/delta/Makefile
 create mode 100644 drivers/media/platform/sti/delta/delta-cfg.h
 create mode 100644 drivers/media/platform/sti/delta/delta-debug.c
 create mode 100644 drivers/media/platform/sti/delta/delta-debug.h
 create mode 100644 drivers/media/platform/sti/delta/delta-ipc.c
 create mode 100644 drivers/media/platform/sti/delta/delta-ipc.h
 create mode 100644 drivers/media/platform/sti/delta/delta-mem.c
 create mode 100644 drivers/media/platform/sti/delta/delta-mem.h
 create mode 100644 drivers/media/platform/sti/delta/delta-mjpeg-dec.c
 create mode 100644 drivers/media/platform/sti/delta/delta-mjpeg-fw.h
 create mode 100644 drivers/media/platform/sti/delta/delta-mjpeg-hdr.c
 create mode 100644 drivers/media/platform/sti/delta/delta-mjpeg.h
 create mode 100644 drivers/media/platform/sti/delta/delta-v4l2.c
 create mode 100644 drivers/media/platform/sti/delta/delta.h
 create mode 100644 drivers/media/platform/sti/hva/Makefile
 create mode 100644 drivers/media/platform/sti/hva/hva-h264.c
 create mode 100644 drivers/media/platform/sti/hva/hva-hw.c
 create mode 100644 drivers/media/platform/sti/hva/hva-hw.h
 create mode 100644 drivers/media/platform/sti/hva/hva-mem.c
 create mode 100644 drivers/media/platform/sti/hva/hva-mem.h
 create mode 100644 drivers/media/platform/sti/hva/hva-v4l2.c
 create mode 100644 drivers/media/platform/sti/hva/hva.h

diff --git a/Documentation/devicetree/bindings/media/st,sti-hva.txt b/Documentation/devicetree/bindings/media/st,sti-hva.txt
new file mode 100644
index 0000000..d1030bb
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,sti-hva.txt
@@ -0,0 +1,24 @@
+hva: multi-format video encoder for STMicroelectronics SoC.
+
+Required properties:
+- compatible: should be "st,sti-hva".
+- reg: HVA physical address location and length, esram address location and
+  length.
+- reg-names: names of the registers listed in registers property in the same
+  order.
+- interrupts: HVA interrupt number.
+- clocks: from common clock binding: handle hardware IP needed clocks, the
+  number of clocks may depend on the SoC type.
+  See ../clock/clock-bindings.txt for details.
+- clock-names: names of the clocks listed in clocks property in the same order.
+
+Example:
+	hva@8c85000{
+		compatible = "st,sti-hva";
+		reg = <0x8c85000 0x400>, <0x6000000 0x40000>;
+		reg-names = "hva_registers", "hva_esram";
+		interrupts = <GIC_SPI 58 IRQ_TYPE_NONE>,
+			     <GIC_SPI 59 IRQ_TYPE_NONE>;
+		clock-names = "clk_hva";
+		clocks = <&clk_s_c0_flexgen CLK_HVA>;
+	};
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 201f5c2..b6a45cc 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -226,6 +226,45 @@ config VIDEO_STI_BDISP
 	help
 	  This v4l2 mem2mem driver is a 2D blitter for STMicroelectronics SoC.
 
+config VIDEO_STI_HVA
+	tristate "STMicroelectronics STiH41x HVA multi-format video encoder V4L2 driver"
+	depends on VIDEO_DEV && VIDEO_V4L2
+	depends on ARCH_STI || COMPILE_TEST
+	select VIDEOBUF2_DMA_CONTIG
+	help
+	  This V4L2 driver enables HVA multi-format video encoder of
+	  STMicroelectronics SoC STiH41x series, allowing hardware encoding of raw
+	  uncompressed formats in various compressed video bitstreams format.
+
+	  To compile this driver as a module, choose M here:
+	  the module will be called hva.
+
+config VIDEO_STI_DELTA
+	tristate "STMicroelectronics STiH41x DELTA multi-format video decoder V4L2 driver"
+	depends on VIDEO_DEV && VIDEO_V4L2
+	depends on ARCH_STI || COMPILE_TEST
+	depends on HAS_DMA
+	depends on RPMSG
+	select VIDEOBUF2_DMA_CONTIG
+	help
+		This V4L2 driver enables DELTA multi-format video decoder
+		of STMicroelectronics SoC STiH41x series allowing
+		hardware decoding of various compressed video bitstream
+		format in raw uncompressed format.
+
+		To compile this driver as a module, choose M here:
+		the module will be called delta.
+
+if VIDEO_STI_DELTA
+
+config VIDEO_STI_DELTA_MJPEG
+	bool "STMicroelectronics DELTA MJPEG support"
+	default y
+	help
+		Enables DELTA MJPEG hardware support.
+
+endif # VIDEO_STI_DELTA
+
 config VIDEO_SH_VEU
 	tristate "SuperH VEU mem2mem video processing driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && HAS_DMA
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index bbb7bd1..6618bfd 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -36,8 +36,11 @@ obj-$(CONFIG_VIDEO_SAMSUNG_S5P_G2D)	+= s5p-g2d/
 obj-$(CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC)	+= exynos-gsc/
 
 obj-$(CONFIG_VIDEO_STI_BDISP)		+= sti/bdisp/
+obj-$(CONFIG_VIDEO_STI_HVA)		+= sti/hva/
 obj-$(CONFIG_DVB_C8SECTPFE)		+= sti/c8sectpfe/
 
+obj-$(CONFIG_VIDEO_STI_DELTA)		+= sti/delta/
+
 obj-$(CONFIG_BLACKFIN)                  += blackfin/
 
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
diff --git a/drivers/media/platform/sti/bdisp/bdisp-v4l2.c b/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
index d12a419..3555334 100644
--- a/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
+++ b/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
@@ -554,6 +554,9 @@ static int queue_init(void *priv,
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	src_vq->lock = &ctx->bdisp_dev->lock;
 
+	/* Temporary allow usage of bytesused = 0 */
+	src_vq->allow_zero_bytesused = 1;
+
 	ret = vb2_queue_init(src_vq);
 	if (ret)
 		return ret;
diff --git a/drivers/media/platform/sti/delta/Makefile b/drivers/media/platform/sti/delta/Makefile
new file mode 100644
index 0000000..da66ed4
--- /dev/null
+++ b/drivers/media/platform/sti/delta/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_VIDEO_STI_DELTA) := delta.o
+delta-y := delta-v4l2.o delta-mem.o delta-ipc.o delta-debug.o
+
+# MJPEG support
+delta-$(CONFIG_VIDEO_STI_DELTA_MJPEG) += delta-mjpeg-hdr.o
+delta-$(CONFIG_VIDEO_STI_DELTA_MJPEG) += delta-mjpeg-dec.o
diff --git a/drivers/media/platform/sti/delta/delta-cfg.h b/drivers/media/platform/sti/delta/delta-cfg.h
new file mode 100644
index 0000000..266f920
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-cfg.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_CFG_H
+#define DELTA_CFG_H
+
+/* output format: only NV12 for the time being */
+#define DELTA_OUT_FMT_FOURCC	V4L2_PIX_FMT_NV12
+
+/* guard value for pixel budget */
+#define DELTA_MAX_RESO		(4096 * 2400)
+
+/* guard value for a single AU size (width x height):
+ * for a MJPEG stream encoded from YUV422 pixel format, assuming a compression
+ * ratio of 2, the maximum size of an AU is (width x height x 2) / 2,
+ * so (width x height)
+ */
+#define DELTA_MAX_AU_SIZE	(DELTA_MAX_RESO)
+
+/* guard value for number of AUs */
+#define DELTA_MAX_AUS		10
+
+/* IP perf dependent, can be tuned */
+#define DELTA_PEAK_FRAME_SMOOTHING	2
+
+/* guard output frame count:
+ * - at least 1 frame needed for display
+ * - at worst 21
+ *   ( max h264 dpb (16) +
+ *   decoding peak smoothing (2) +
+ *   user display pipeline (3) )
+ */
+#define DELTA_MIN_FRAME_USER	1
+#define DELTA_MAX_DPB		16
+#define DELTA_MAX_FRAME_USER	3	/* platform/use-case dependent */
+#define DELTA_MAX_FRAMES (DELTA_MAX_DPB + DELTA_PEAK_FRAME_SMOOTHING \
+		+ DELTA_MAX_FRAME_USER)
+
+#ifndef VIDEO_MAX_FRAME
+#error "VIDEO_MAX_FRAME not defined, please include videodev2.h"
+#endif
+#if DELTA_MAX_FRAMES > VIDEO_MAX_FRAME
+#undef DELTA_MAX_FRAMES
+#define DELTA_MAX_FRAMES (VIDEO_MAX_FRAME)
+#endif
+
+/* extra space to be allocated to store codec specific data per frame */
+#define DELTA_MAX_FRAME_PRIV_SIZE 100
+
+/* PM runtime auto power-off after 5ms of inactivity */
+#define DELTA_HW_AUTOSUSPEND_DELAY_MS	5
+
+#ifdef CONFIG_VIDEO_STI_DELTA_MJPEG
+extern const struct delta_dec mjpegdec;
+#endif
+
+#endif /* DELTA_CFG_H */
diff --git a/drivers/media/platform/sti/delta/delta-debug.c b/drivers/media/platform/sti/delta/delta-debug.c
new file mode 100644
index 0000000..2eae96a
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-debug.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Fabrice Lecoultre <fabrice.lecoultre@st.com>
+ *          for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/debugfs.h>
+
+#include "delta.h"
+#include "delta-debug.h"
+
+char *delta_streaminfo_str(struct delta_streaminfo *s, char *str,
+			   unsigned int len)
+{
+	char *cur = str;
+	size_t left = len;
+	int ret = 0;
+	int cnt = 0;
+
+	if (!s)
+		return NULL;
+
+	ret = snprintf(cur, left,
+		       "%4.4s %dx%d %s %s frame wxh=%dx%d dpb=%d %s",
+		       (char *)&s->streamformat,
+		       s->width, s->height,
+		       s->profile, s->level,
+		       s->frame_width, s->frame_height, s->dpb,
+		       (s->field == V4L2_FIELD_NONE) ?
+		       "progressive" : "interlaced");
+	cnt = (left > ret ? ret : left);
+
+	if (s->flags & DELTA_STREAMINFO_FLAG_CROP) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       " crop=%dx%d@(%d,%d)",
+			       s->crop.width, s->crop.height,
+			       s->crop.left, s->crop.top);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (s->flags & DELTA_STREAMINFO_FLAG_PIXELASPECT) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       " pixel aspect=%d/%d",
+			       s->pixelaspect.numerator,
+			       s->pixelaspect.denominator);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (s->flags & DELTA_STREAMINFO_FLAG_OTHER) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left, " %s", s->other);
+		cnt = (left > ret ? ret : left);
+	}
+
+	return str;
+}
+
+char *delta_summary_str(struct delta_ctx *ctx, char *str, unsigned int len)
+{
+	char *cur = str;
+	size_t left = len;
+	int cnt = 0;
+	int ret = 0;
+	unsigned char sstr[200] = "";
+
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO))
+		return NULL;
+
+	ret = snprintf(cur, left,
+		       "%s",
+		       delta_streaminfo_str(&ctx->streaminfo, sstr,
+					    sizeof(sstr)));
+	cnt = (left > ret ? ret : left);
+
+	if (ctx->decoded_frames) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       ", %d frames decoded", ctx->decoded_frames);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (ctx->output_frames) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       ", %d frames output", ctx->output_frames);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (ctx->dropped_frames) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       ", %d frames dropped", ctx->dropped_frames);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (ctx->stream_errors) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       ", %d stream errors", ctx->stream_errors);
+		cnt = (left > ret ? ret : left);
+	}
+
+	if (ctx->decode_errors) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       ", %d decode errors", ctx->decode_errors);
+		cnt = (left > ret ? ret : left);
+	}
+
+	return str;
+}
diff --git a/drivers/media/platform/sti/delta/delta-debug.h b/drivers/media/platform/sti/delta/delta-debug.h
new file mode 100644
index 0000000..ca5cbf4
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-debug.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Fabrice Lecoultre <fabrice.lecoultre@st.com>
+ *          for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_DEBUG_H
+#define DELTA_DEBUG_H
+
+char *delta_streaminfo_str(struct delta_streaminfo *s, char *str,
+			   unsigned int len);
+char *delta_summary_str(struct delta_ctx *ctx, char *str, unsigned int len);
+
+#endif /* DELTA_DEBUG_H */
diff --git a/drivers/media/platform/sti/delta/delta-ipc.c b/drivers/media/platform/sti/delta/delta-ipc.c
new file mode 100644
index 0000000..6aa333c
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-ipc.c
@@ -0,0 +1,589 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/rpmsg.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+
+#include "delta.h"
+#include "delta-mem.h"
+
+#define IPC_TIMEOUT 100
+#define IPC_SANITY_TAG 0xDEADBEEF
+
+enum delta_ipc_fw_command {
+	DELTA_IPC_OPEN,
+	DELTA_IPC_SET_STREAM,
+	DELTA_IPC_DECODE,
+	DELTA_IPC_CLOSE
+};
+
+#define to_rpmsg_driver(d) container_of(d, struct rpmsg_driver, drv)
+#define to_delta(d) container_of(d, struct delta_dev, rpmsg_driver)
+
+#define to_ctx(hdl) ((struct delta_ipc_ctx *)hdl)
+#define to_pctx(ctx) container_of(ctx, struct delta_ctx, ipc_ctx)
+
+struct delta_ipc_header_msg {
+	__u32 tag;
+	__u32 host_hdl;		/*FIXME for 64 bits host */
+	__u32 copro_hdl;
+	__u32 command;
+};
+
+#define to_host_hdl(ctx) ((__u32)ctx)	/*FIXME for 64 bits host */
+
+#define msg_to_ctx(msg) ((struct delta_ipc_ctx *)msg->header.host_hdl)
+#define msg_to_copro_hdl(msg) (msg->header.copro_hdl)
+
+static inline dma_addr_t to_paddr(struct delta_ipc_ctx *ctx, void *vaddr)
+{
+	return (ctx->ipc_buf->paddr + (vaddr - ctx->ipc_buf->vaddr));
+}
+
+static inline bool is_valid_data(struct delta_ipc_ctx *ctx,
+				 void *data, __u32 size)
+{
+	return ((data >= ctx->ipc_buf->vaddr) &&
+		((data + size) <= (ctx->ipc_buf->vaddr + ctx->ipc_buf->size)));
+}
+
+/*
+ * IPC shared memory (@ipc_buf_size, @ipc_buf_paddr) is sent to copro
+ * at each instance opening. This memory is allocated by IPC client
+ * and given through delta_ipc_open(). All messages parameters
+ * (open, set_stream, decode) will have their phy address within
+ * this IPC shared memory, avoiding de-facto recopies inside delta-ipc.
+ */
+struct delta_ipc_open_msg {
+	struct delta_ipc_header_msg header;
+	__u32 ipc_buf_size;
+	dma_addr_t ipc_buf_paddr;
+	char name[32];
+	__u32 param_size;
+	dma_addr_t param_paddr;
+};
+
+struct delta_ipc_set_stream_msg {
+	struct delta_ipc_header_msg header;
+	__u32 param_size;
+	dma_addr_t param_paddr;
+};
+
+struct delta_ipc_decode_msg {
+	struct delta_ipc_header_msg header;
+	__u32 param_size;
+	dma_addr_t param_paddr;
+	__u32 status_size;
+	dma_addr_t status_paddr;
+};
+
+struct delta_ipc_close_msg {
+	struct delta_ipc_header_msg header;
+};
+
+struct delta_ipc_cb_msg {
+	struct delta_ipc_header_msg header;
+	int err;
+};
+
+static void build_msg_header(struct delta_ipc_ctx *ctx,
+			     enum delta_ipc_fw_command command,
+			     struct delta_ipc_header_msg *header)
+{
+	header->tag = IPC_SANITY_TAG;
+	header->host_hdl = to_host_hdl(ctx);
+	header->copro_hdl = ctx->copro_hdl;
+	header->command = command;
+}
+
+int delta_ipc_open(struct delta_ctx *pctx, const char *name,
+		   struct delta_ipc_param *param, __u32 ipc_buf_size,
+		   struct delta_buf **ipc_buf, void **hdl)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct rpmsg_channel *rpmsg_channel = delta->rpmsg_channel;
+	struct delta_ipc_ctx *ctx = &pctx->ipc_ctx;
+	struct delta_ipc_open_msg msg;
+	struct delta_buf *buf = &ctx->ipc_buf_struct;
+	int ret;
+
+	if (!rpmsg_channel) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, rpmsg is not initialized\n",
+			pctx->name);
+		pctx->sys_errors++;
+		return -EINVAL;
+	}
+
+	if (!name) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, no name given\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!param || !param->data || !param->size) {
+		dev_err(delta->dev,
+			"%s  ipc: failed to open, empty parameter\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!ipc_buf_size) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, no size given for ipc buffer\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (param->size > ipc_buf_size) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, too large ipc parameter (%d bytes while max %d expected)\n",
+			pctx->name,
+			param->size, ctx->ipc_buf->size);
+		return -EINVAL;
+	}
+
+	/* init */
+	init_completion(&ctx->done);
+
+	/* allocation of contiguous buffer for
+	 * data of commands exchanged between
+	 * host and firmware coprocessor
+	 */
+	ret = hw_alloc(pctx, ipc_buf_size,
+		       "ipc data buffer", buf);
+	if (ret)
+		return ret;
+	ctx->ipc_buf = buf;
+
+	/* build rpmsg message */
+	build_msg_header(ctx, DELTA_IPC_OPEN, &msg.header);
+
+	msg.ipc_buf_size = ipc_buf_size;
+	msg.ipc_buf_paddr = ctx->ipc_buf->paddr;
+
+	memcpy(msg.name, name, sizeof(msg.name));
+	msg.name[sizeof(msg.name) - 1] = 0;
+
+	msg.param_size = param->size;
+	memcpy(ctx->ipc_buf->vaddr, param->data, msg.param_size);
+	msg.param_paddr = ctx->ipc_buf->paddr;
+
+	/* send it */
+	ret = rpmsg_send(rpmsg_channel, &msg, sizeof(msg));
+	if (ret) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, rpmsg_send failed (%d) for DELTA_IPC_OPEN (name=%s, size=%d, data=%p)\n",
+			pctx->name,
+			ret, name, param->size, param->data);
+		goto err;
+	}
+
+	/* wait for acknowledge */
+	if (!wait_for_completion_timeout
+	    (&ctx->done, msecs_to_jiffies(IPC_TIMEOUT))) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, timeout waiting for DELTA_IPC_OPEN callback (name=%s, size=%d, data=%p)\n",
+			pctx->name,
+			name, param->size, param->data);
+		ret = -ETIMEDOUT;
+		goto err;
+	}
+
+	/* command completed, check error */
+	if (ctx->cb_err) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to open, DELTA_IPC_OPEN completed but with error (%d) (name=%s, size=%d, data=%p)\n",
+			pctx->name,
+			ctx->cb_err, name, param->size, param->data);
+		ret = -EIO;
+		goto err;
+	}
+
+	*ipc_buf = ctx->ipc_buf;
+	*hdl = (void *)ctx;
+
+	return 0;
+
+err:
+	pctx->sys_errors++;
+	if (ctx->ipc_buf) {
+		hw_free(pctx, ctx->ipc_buf);
+		ctx->ipc_buf = NULL;
+	}
+
+	return ret;
+};
+
+int delta_ipc_set_stream(void *hdl, struct delta_ipc_param *param)
+{
+	struct delta_ipc_ctx *ctx = to_ctx(hdl);
+	struct delta_ctx *pctx = to_pctx(ctx);
+	struct delta_dev *delta = pctx->dev;
+	struct rpmsg_channel *rpmsg_channel = delta->rpmsg_channel;
+	struct delta_ipc_set_stream_msg msg;
+	int ret;
+
+	if (!hdl) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, invalid ipc handle\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!rpmsg_channel) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, rpmsg is not initialized\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!param || !param->data || !param->size) {
+		dev_err(delta->dev,
+			"%s  ipc: failed to set stream, empty parameter\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (param->size > ctx->ipc_buf->size) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, too large ipc parameter(%d bytes while max %d expected)\n",
+			pctx->name,
+			param->size, ctx->ipc_buf->size);
+		return -EINVAL;
+	}
+
+	if (!is_valid_data(ctx, param->data, param->size)) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, parameter is not in expected address range (size=%d, data=%p not in %p..%p)\n",
+			pctx->name,
+			param->size,
+			param->data,
+			ctx->ipc_buf->vaddr,
+			ctx->ipc_buf->vaddr + ctx->ipc_buf->size - 1);
+		return -EINVAL;
+	}
+
+	/* build rpmsg message */
+	build_msg_header(ctx, DELTA_IPC_SET_STREAM, &msg.header);
+
+	msg.param_size = param->size;
+	msg.param_paddr = to_paddr(ctx, param->data);
+
+	/* send it */
+	ret = rpmsg_send(rpmsg_channel, &msg, sizeof(msg));
+	if (ret) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, rpmsg_send failed (%d) for DELTA_IPC_SET_STREAM (size=%d, data=%p)\n",
+			pctx->name,
+			ret, param->size, param->data);
+		pctx->sys_errors++;
+		return ret;
+	}
+
+	/* wait for acknowledge */
+	if (!wait_for_completion_timeout
+	    (&ctx->done, msecs_to_jiffies(IPC_TIMEOUT))) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, timeout waiting for DELTA_IPC_SET_STREAM callback (size=%d, data=%p)\n",
+			pctx->name,
+			param->size, param->data);
+		pctx->sys_errors++;
+		return -ETIMEDOUT;
+	}
+
+	/* command completed, check status */
+	if (ctx->cb_err) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to set stream, DELTA_IPC_SET_STREAM completed but with error (%d) (size=%d, data=%p)\n",
+			pctx->name,
+			ctx->cb_err, param->size, param->data);
+		pctx->sys_errors++;
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int delta_ipc_decode(void *hdl, struct delta_ipc_param *param,
+		     struct delta_ipc_param *status)
+{
+	struct delta_ipc_ctx *ctx = to_ctx(hdl);
+	struct delta_ctx *pctx = to_pctx(ctx);
+	struct delta_dev *delta = pctx->dev;
+	struct rpmsg_channel *rpmsg_channel = delta->rpmsg_channel;
+	struct delta_ipc_decode_msg msg;
+	int ret;
+
+	if (!hdl) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, invalid ipc handle\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!rpmsg_channel) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, rpmsg is not initialized\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!param || !param->data || !param->size) {
+		dev_err(delta->dev,
+			"%s  ipc: failed to decode, empty parameter\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (!status || !status->data || !status->size) {
+		dev_err(delta->dev,
+			"%s  ipc: failed to decode, empty status\n",
+			pctx->name);
+		return -EINVAL;
+	}
+
+	if (param->size + status->size > ctx->ipc_buf->size) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, too large ipc parameter (%d bytes (param) + %d bytes (status) while max %d expected)\n",
+			pctx->name,
+			param->size,
+			status->size,
+			ctx->ipc_buf->size);
+		return -EINVAL;
+	}
+
+	if (!is_valid_data(ctx, param->data, param->size)) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, parameter is not in expected address range (size=%d, data=%p not in %p..%p)\n",
+			pctx->name,
+			param->size,
+			param->data,
+			ctx->ipc_buf->vaddr,
+			ctx->ipc_buf->vaddr + ctx->ipc_buf->size - 1);
+		return -EINVAL;
+	}
+
+	if (!is_valid_data(ctx, status->data, status->size)) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, status is not in expected address range (size=%d, data=%p not in %p..%p)\n",
+			pctx->name,
+			status->size,
+			status->data,
+			ctx->ipc_buf->vaddr,
+			ctx->ipc_buf->vaddr + ctx->ipc_buf->size - 1);
+		return -EINVAL;
+	}
+
+	/* build rpmsg message */
+	build_msg_header(ctx, DELTA_IPC_DECODE, &msg.header);
+
+	msg.param_size = param->size;
+	msg.param_paddr = to_paddr(ctx, param->data);
+
+	msg.status_size = status->size;
+	msg.status_paddr = to_paddr(ctx, status->data);
+
+	/* send it */
+	ret = rpmsg_send(rpmsg_channel, &msg, sizeof(msg));
+	if (ret) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, rpmsg_send failed (%d) for DELTA_IPC_DECODE (size=%d, data=%p)\n",
+			pctx->name,
+			ret, param->size, param->data);
+		pctx->sys_errors++;
+		return ret;
+	}
+
+	/* wait for acknowledge */
+	if (!wait_for_completion_timeout
+	    (&ctx->done, msecs_to_jiffies(IPC_TIMEOUT))) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, timeout waiting for DELTA_IPC_DECODE callback (size=%d, data=%p)\n",
+			pctx->name,
+			param->size, param->data);
+		pctx->sys_errors++;
+		return -ETIMEDOUT;
+	}
+
+	/* command completed, check status */
+	if (ctx->cb_err) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to decode, DELTA_IPC_DECODE completed but with error (%d) (size=%d, data=%p)\n",
+			pctx->name,
+			ctx->cb_err, param->size, param->data);
+		pctx->sys_errors++;
+		return -EIO;
+	}
+
+	return 0;
+};
+
+void delta_ipc_close(void *hdl)
+{
+	struct delta_ipc_ctx *ctx = to_ctx(hdl);
+	struct delta_ctx *pctx = to_pctx(ctx);
+	struct delta_dev *delta = pctx->dev;
+	struct rpmsg_channel *rpmsg_channel = delta->rpmsg_channel;
+	struct delta_ipc_close_msg msg;
+	int ret;
+
+	if (!hdl) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to close, invalid ipc handle\n",
+			pctx->name);
+		return;
+	}
+
+	if (ctx->ipc_buf) {
+		hw_free(pctx, ctx->ipc_buf);
+		ctx->ipc_buf = NULL;
+	}
+
+	if (!rpmsg_channel) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to close, rpmsg is not initialized\n",
+			pctx->name);
+		return;
+	}
+
+	/* build rpmsg message */
+	build_msg_header(ctx, DELTA_IPC_CLOSE, &msg.header);
+
+	/* send it */
+	ret = rpmsg_send(rpmsg_channel, &msg, sizeof(msg));
+	if (ret) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to close, rpmsg_send failed (%d) for DELTA_IPC_CLOSE\n",
+			pctx->name, ret);
+		pctx->sys_errors++;
+		return;
+	}
+
+	/* wait for acknowledge */
+	if (!wait_for_completion_timeout
+	    (&ctx->done, msecs_to_jiffies(IPC_TIMEOUT))) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to close, timeout waiting for DELTA_IPC_CLOSE callback\n",
+			pctx->name);
+		pctx->sys_errors++;
+		return;
+	}
+
+	/* command completed, check status */
+	if (ctx->cb_err) {
+		dev_err(delta->dev,
+			"%s   ipc: failed to close, DELTA_IPC_CLOSE completed but with error (%d)\n",
+			pctx->name, ctx->cb_err);
+		pctx->sys_errors++;
+	}
+};
+
+static void delta_ipc_cb(struct rpmsg_channel *rpmsg_channel, void *data,
+			 int len, void *priv, u32 src)
+{
+	struct delta_ipc_ctx *ctx;
+	struct delta_ipc_cb_msg *msg;
+
+	/* sanity check */
+	if (!rpmsg_channel) {
+		dev_err(NULL, "rpmsg_channel is NULL\n");
+		return;
+	}
+
+	if (!data || !len) {
+		dev_err(&rpmsg_channel->dev,
+			"unexpected empty message received from src=%d\n", src);
+		return;
+	}
+
+	if (len != sizeof(*msg)) {
+		dev_err(&rpmsg_channel->dev,
+			"unexpected message length received from src=%d (received %d bytes while %d bytes expected)\n",
+			len, src, sizeof(*msg));
+		return;
+	}
+
+	msg = (struct delta_ipc_cb_msg *)data;
+	if (msg->header.tag != IPC_SANITY_TAG) {
+		dev_err(&rpmsg_channel->dev,
+			"unexpected message tag received from src=%d (received %x tag while %x expected)\n",
+			src, msg->header.tag, IPC_SANITY_TAG);
+		return;
+	}
+
+	ctx = msg_to_ctx(msg);
+	if (!ctx) {
+		dev_err(&rpmsg_channel->dev,
+			"unexpected message with NULL host_hdl received from src=%d\n",
+			src);
+		return;
+	}
+
+	/* if not already known, save copro instance context
+	 * to ensure re-entrance on copro side
+	 */
+	if (!ctx->copro_hdl)
+		ctx->copro_hdl = msg_to_copro_hdl(msg);
+
+	/* all is fine,
+	 * update status & complete command
+	 */
+	ctx->cb_err = msg->err;
+	complete(&ctx->done);
+}
+
+static int delta_ipc_probe(struct rpmsg_channel *rpmsg_channel)
+{
+	struct rpmsg_driver *rpdrv = to_rpmsg_driver(rpmsg_channel->dev.driver);
+	struct delta_dev *delta = to_delta(rpdrv);
+
+	delta->rpmsg_channel = rpmsg_channel;
+
+	return 0;
+}
+
+static void delta_ipc_remove(struct rpmsg_channel *rpmsg_channel)
+{
+	struct rpmsg_driver *rpdrv = to_rpmsg_driver(rpmsg_channel->dev.driver);
+	struct delta_dev *delta = to_delta(rpdrv);
+
+	delta->rpmsg_channel = NULL;
+}
+
+static struct rpmsg_device_id delta_ipc_device_id_table[] = {
+	{.name = "rpmsg-delta"},
+	{},
+};
+
+static struct rpmsg_driver delta_rpmsg_driver = {
+	.drv.name = KBUILD_MODNAME,
+	.drv.owner = THIS_MODULE,
+	.id_table = delta_ipc_device_id_table,
+	.probe = delta_ipc_probe,
+	.callback = delta_ipc_cb,
+	.remove = delta_ipc_remove,
+};
+
+int delta_ipc_init(struct delta_dev *delta)
+{
+	delta->rpmsg_driver = delta_rpmsg_driver;
+
+	register_rpmsg_driver(&delta->rpmsg_driver);
+	return 0;
+}
+
+void delta_ipc_exit(struct delta_dev *delta)
+{
+	unregister_rpmsg_driver(&delta->rpmsg_driver);
+}
diff --git a/drivers/media/platform/sti/delta/delta-ipc.h b/drivers/media/platform/sti/delta/delta-ipc.h
new file mode 100644
index 0000000..153a338
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-ipc.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_IPC_H
+#define DELTA_IPC_H
+
+int delta_ipc_init(struct delta_dev *delta);
+void delta_ipc_exit(struct delta_dev *delta);
+
+/**
+ * delta_ipc_open - open a decoding instance on firmware side
+ * @ctx:		(in) delta context
+ * @name:		(in) name of decoder to be used
+ * @param:		(in) open command parameters specific to decoder
+ *  @param.size:		(in) size of parameter
+ *  @param.data:		(in) virtual address of parameter
+ * @ipc_buf_size:	(in) size of IPC shared buffer between host
+ *			     and copro used to share command data.
+ *			     Client have to set here the size of the biggest
+ *			     command parameters (+ status if any).
+ *			     Allocation will be done in this function which
+ *			     will give back to client in @ipc_buf the virtual
+ *			     & physical addresses & size of shared IPC buffer.
+ *			     All the further command data (parameters + status)
+ *			     have to be written in this shared IPC buffer
+ *			     virtual memory. This is done to avoid
+ *			     unnecessary copies of command data.
+ * @ipc_buf:		(out) allocated IPC shared buffer
+ *  @ipc_buf.size:		(out) allocated size
+ *  @ipc_buf.vaddr:		(out) virtual address where to copy
+ *				      further command data
+ * @hdl:		(out) handle of decoding instance.
+ */
+
+int delta_ipc_open(struct delta_ctx *ctx, const char *name,
+		   struct delta_ipc_param *param, __u32 ipc_buf_size,
+		   struct delta_buf **ipc_buf, void **hdl);
+
+/**
+ * delta_ipc_set_stream - set information about stream to decoder
+ * @hdl:		(in) handle of decoding instance.
+ * @param:		(in) set stream command parameters specific to decoder
+ *  @param.size:		(in) size of parameter
+ *  @param.data:		(in) virtual address of parameter. Must be
+ *				     within IPC shared buffer range
+*/
+int delta_ipc_set_stream(void *hdl, struct delta_ipc_param *param);
+
+/**
+ * delta_ipc_decode - frame decoding synchronous request, returns only
+ *		      after decoding completion on firmware side.
+ * @hdl:		(in) handle of decoding instance.
+ * @param:		(in) decode command parameters specific to decoder
+ *  @param.size:		(in) size of parameter
+ *  @param.data:		(in) virtual address of parameter. Must be
+ *				     within IPC shared buffer range
+ * @status:		(in/out) decode command status specific to decoder
+ *  @status.size:		(in) size of status
+ *  @status.data:		(in/out) virtual address of status. Must be
+ *					 within IPC shared buffer range.
+ *					 Status is filled by decoding instance
+ *					 after decoding completion.
+*/
+int delta_ipc_decode(void *hdl, struct delta_ipc_param *param,
+		     struct delta_ipc_param *status);
+
+/**
+ * delta_ipc_close - close decoding instance
+ * @hdl:		(in) handle of decoding instance to close.
+*/
+void delta_ipc_close(void *hdl);
+
+#endif /* DELTA_IPC_H */
diff --git a/drivers/media/platform/sti/delta/delta-mem.c b/drivers/media/platform/sti/delta/delta-mem.c
new file mode 100644
index 0000000..11b95b2
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mem.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Chetan Nanda <chetan.nanda@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ *          for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "delta.h"
+#include "delta-mem.h"
+
+int hw_alloc(struct delta_ctx *ctx, __u32 size, const char *name,
+	     struct delta_buf *buf)
+{
+	struct delta_dev *delta = ctx->dev;
+	dma_addr_t dma_addr;
+	void *addr;
+	struct dma_attrs *attrs = NULL;
+	DEFINE_DMA_ATTRS(attrs_struct);
+
+	buf->attrs_struct = attrs_struct;
+	attrs = &buf->attrs_struct;
+	dma_set_attr(DMA_ATTR_WRITE_COMBINE, attrs);
+	addr = dma_alloc_attrs(delta->dev, size, &dma_addr,
+			       GFP_KERNEL | __GFP_NOWARN, attrs);
+	if (!addr) {
+		dev_err(delta->dev,
+			"%s hw_alloc:dma_alloc_coherent failed for %s (size=%d)\n",
+			ctx->name, name, size);
+		ctx->sys_errors++;
+		return -ENOMEM;
+	};
+
+	buf->size = size;
+	buf->paddr = dma_addr;
+	buf->vaddr = addr;
+	buf->name = name;
+	buf->attrs = attrs;
+
+	dev_dbg(delta->dev,
+		"%s allocate %d bytes of HW memory @(virt=%p, phy=%x): %s\n",
+		ctx->name, size, buf->vaddr, buf->paddr, buf->name);
+
+	return 0;
+}
+
+void hw_free(struct delta_ctx *ctx, struct delta_buf *buf)
+{
+	struct delta_dev *delta = ctx->dev;
+
+	dev_dbg(delta->dev,
+		"%s     free %d bytes of HW memory @(virt=%p, phy=%x): %s\n",
+		ctx->name, buf->size, buf->vaddr, buf->paddr, buf->name);
+
+	dma_free_attrs(delta->dev, buf->size,
+		       buf->vaddr, buf->paddr, buf->attrs);
+}
diff --git a/drivers/media/platform/sti/delta/delta-mem.h b/drivers/media/platform/sti/delta/delta-mem.h
new file mode 100644
index 0000000..d1ae876
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mem.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Chetan Nanda <chetan.nanda@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ *          for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_MEM_H
+#define DELTA_MEM_H
+
+int hw_alloc(struct delta_ctx *ctx, __u32 size, const char *name,
+	     struct delta_buf *buf);
+void hw_free(struct delta_ctx *ctx, struct delta_buf *buf);
+
+#endif /* DELTA_MEM_H */
diff --git a/drivers/media/platform/sti/delta/delta-mjpeg-dec.c b/drivers/media/platform/sti/delta/delta-mjpeg-dec.c
new file mode 100644
index 0000000..91d05f3
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mjpeg-dec.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2013
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "delta.h"
+#include "delta-mjpeg.h"
+#include "delta-ipc.h"
+
+#define DELTA_MJPEG_MAX_RESO DELTA_MAX_RESO
+
+static char *ipc_open_param_str(struct jpeg_video_decode_init_params_t *p,
+				char *str, unsigned int len)
+{
+	char *b = str;
+
+	if (!p)
+		return "";
+
+	b += snprintf(b, len,
+		      "jpeg_video_decode_init_params_t\n"
+		      "circular_buffer_begin_addr_p 0x%x\n"
+		      "circular_buffer_end_addr_p   0x%x\n",
+		      p->circular_buffer_begin_addr_p,
+		      p->circular_buffer_end_addr_p);
+
+	return str;
+}
+
+static char *ipc_decode_param_str(struct jpeg_decode_params_t *p,
+				  char *str, unsigned int len)
+{
+	char *b = str;
+
+	if (!p)
+		return "";
+
+	b += snprintf(b, len,
+		      "jpeg_decode_params_t\n"
+		      "picture_start_addr_p                  0x%x\n"
+		      "picture_end_addr_p                    0x%x\n"
+		      "decoding_mode                        %d\n"
+		      "display_buffer_addr.display_decimated_luma_p   0x%x\n"
+		      "display_buffer_addr.display_decimated_chroma_p 0x%x\n"
+		      "main_aux_enable                       %d\n"
+		      "additional_flags                     0x%x\n",
+		      p->picture_start_addr_p,
+		      p->picture_end_addr_p,
+		      p->decoding_mode,
+		      p->display_buffer_addr.display_decimated_luma_p,
+		      p->display_buffer_addr.display_decimated_chroma_p,
+		      p->main_aux_enable, p->additional_flags);
+
+	return str;
+}
+
+static inline int to_ret(enum jpeg_decoding_error_t err)
+{
+	switch (err) {
+	case JPEG_DECODER_NO_ERROR:
+		return 0;
+
+	case JPEG_DECODER_UNABLE_ALLOCATE_MEMORY:
+		return -ENOMEM;
+
+	case JPEG_DECODER_UNSUPPORTED_MARKER:
+	case JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS:
+	case JPEG_DECODER_BAD_PARAMETER:
+	case JPEG_DECODER_UNSUPPORTED_COLORSPACE:
+	case JPEG_DECODER_NOT_JPG_IMAGE:
+	case JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE:
+	case JPEG_DECODER_UNSUPPORTED_SCALING:
+	case JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE:
+	case JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE:
+	case JPEG_DECODER_BAD_VALUE_FROM_RED:
+	case JPEG_DECODER_BAD_SUBREGION_PARAMETERS:
+	case JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED:
+		return -EINVAL;
+
+	case JPEG_DECODER_ERROR_TASK_TIMEOUT:
+		return -ETIMEDOUT;
+
+	default:
+		return -EIO;
+	}
+}
+
+static inline bool is_stream_error(enum jpeg_decoding_error_t err)
+{
+	switch (err) {
+	case JPEG_DECODER_UNDEFINED_HUFF_TABLE:
+	case JPEG_DECODER_BAD_RESTART_MARKER:
+	case JPEG_DECODER_BAD_SOS_SPECTRAL:
+	case JPEG_DECODER_BAD_SOS_SUCCESSIVE:
+	case JPEG_DECODER_BAD_HEADER_LENGTH:
+	case JPEG_DECODER_BAD_COUNT_VALUE:
+	case JPEG_DECODER_BAD_DHT_MARKER:
+	case JPEG_DECODER_BAD_INDEX_VALUE:
+	case JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES:
+	case JPEG_DECODER_BAD_QUANT_TABLE_LENGTH:
+	case JPEG_DECODER_BAD_NUMBER_QUANT_TABLES:
+	case JPEG_DECODER_BAD_COMPONENT_COUNT:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline const char *err_str(enum jpeg_decoding_error_t err)
+{
+	switch (err) {
+	case JPEG_DECODER_NO_ERROR:
+		return "JPEG_DECODER_NO_ERROR";
+	case JPEG_DECODER_UNDEFINED_HUFF_TABLE:
+		return "JPEG_DECODER_UNDEFINED_HUFF_TABLE";
+	case JPEG_DECODER_UNSUPPORTED_MARKER:
+		return "JPEG_DECODER_UNSUPPORTED_MARKER";
+	case JPEG_DECODER_UNABLE_ALLOCATE_MEMORY:
+		return "JPEG_DECODER_UNABLE_ALLOCATE_MEMORY";
+	case JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS:
+		return "JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS";
+	case JPEG_DECODER_BAD_PARAMETER:
+		return "JPEG_DECODER_BAD_PARAMETER";
+	case JPEG_DECODER_DECODE_ERROR:
+		return "JPEG_DECODER_DECODE_ERROR";
+	case JPEG_DECODER_BAD_RESTART_MARKER:
+		return "JPEG_DECODER_BAD_RESTART_MARKER";
+	case JPEG_DECODER_UNSUPPORTED_COLORSPACE:
+		return "JPEG_DECODER_UNSUPPORTED_COLORSPACE";
+	case JPEG_DECODER_BAD_SOS_SPECTRAL:
+		return "JPEG_DECODER_BAD_SOS_SPECTRAL";
+	case JPEG_DECODER_BAD_SOS_SUCCESSIVE:
+		return "JPEG_DECODER_BAD_SOS_SUCCESSIVE";
+	case JPEG_DECODER_BAD_HEADER_LENGTH:
+		return "JPEG_DECODER_BAD_HEADER_LENGTH";
+	case JPEG_DECODER_BAD_COUNT_VALUE:
+		return "JPEG_DECODER_BAD_COUNT_VALUE";
+	case JPEG_DECODER_BAD_DHT_MARKER:
+		return "JPEG_DECODER_BAD_DHT_MARKER";
+	case JPEG_DECODER_BAD_INDEX_VALUE:
+		return "JPEG_DECODER_BAD_INDEX_VALUE";
+	case JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES:
+		return "JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES";
+	case JPEG_DECODER_BAD_QUANT_TABLE_LENGTH:
+		return "JPEG_DECODER_BAD_QUANT_TABLE_LENGTH";
+	case JPEG_DECODER_BAD_NUMBER_QUANT_TABLES:
+		return "JPEG_DECODER_BAD_NUMBER_QUANT_TABLES";
+	case JPEG_DECODER_BAD_COMPONENT_COUNT:
+		return "JPEG_DECODER_BAD_COMPONENT_COUNT";
+	case JPEG_DECODER_DIVIDE_BY_ZERO_ERROR:
+		return "JPEG_DECODER_DIVIDE_BY_ZERO_ERROR";
+	case JPEG_DECODER_NOT_JPG_IMAGE:
+		return "JPEG_DECODER_NOT_JPG_IMAGE";
+	case JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE:
+		return "JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE";
+	case JPEG_DECODER_UNSUPPORTED_SCALING:
+		return "JPEG_DECODER_UNSUPPORTED_SCALING";
+	case JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE:
+		return "JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE";
+	case JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE:
+		return "JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE";
+	case JPEG_DECODER_BAD_VALUE_FROM_RED:
+		return "JPEG_DECODER_BAD_VALUE_FROM_RED";
+	case JPEG_DECODER_BAD_SUBREGION_PARAMETERS:
+		return "JPEG_DECODER_BAD_SUBREGION_PARAMETERS";
+	case JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED:
+		return "JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED";
+	case JPEG_DECODER_ERROR_TASK_TIMEOUT:
+		return "JPEG_DECODER_ERROR_TASK_TIMEOUT";
+	default:
+		return "!unknown MJPEG error!";
+	}
+}
+
+static void delta_mjpeg_check_status(struct delta_ctx *pctx,
+				     struct jpeg_decode_return_params_t *status)
+{
+	struct delta_dev *delta = pctx->dev;
+
+	if (status->error_code != JPEG_DECODER_NO_ERROR) {
+		dev_warn(delta->dev,
+			 "%s  firmware: MME_TRANSFORM error: %s\n",
+			 pctx->name, err_str(status->error_code));
+		pctx->decode_errors++;
+	}
+
+	if (is_stream_error(status->error_code)) {
+		dev_warn_ratelimited(delta->dev,
+				     "%s  firmware: stream error @ frame %d (%s)\n",
+				     pctx->name, pctx->decoded_frames,
+				     err_str(status->error_code));
+		pctx->stream_errors++;
+	}
+#if (JPEGHW_MME_VERSION >= 17)
+	dev_dbg(delta->dev,
+		"%s  firmware: decoding time(us)=%d\n", pctx->name,
+		status->decode_time_in_micros);
+#endif
+}
+
+static int delta_mjpeg_ipc_open(struct delta_ctx *pctx)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+	int ret = 0;
+	struct jpeg_video_decode_init_params_t params_struct;
+	struct jpeg_video_decode_init_params_t *params = &params_struct;
+	struct delta_buf *ipc_buf;
+	__u32 ipc_buf_size;
+	struct delta_ipc_param ipc_param;
+	void *hdl;
+
+	memset(params, 0, sizeof(*params));
+	params->circular_buffer_begin_addr_p = 0x00000000;
+	params->circular_buffer_end_addr_p = 0xffffffff;
+
+	dev_vdbg(delta->dev,
+		 "%s  %s\n", pctx->name,
+		 ipc_open_param_str(params, ctx->str, sizeof(ctx->str)));
+
+	ipc_param.size = sizeof(*params);
+	ipc_param.data = params;
+	ipc_buf_size = sizeof(struct jpeg_decode_params_t) +
+	    sizeof(struct jpeg_decode_return_params_t);
+	ret = delta_ipc_open(pctx, "JPEG_DECODER_HW0", &ipc_param,
+			     ipc_buf_size, &ipc_buf, &hdl);
+	if (ret) {
+		dev_err(delta->dev,
+			"%s  dumping command %s\n", pctx->name,
+			ipc_open_param_str(params, ctx->str, sizeof(ctx->str)));
+		return ret;
+	}
+
+	ctx->ipc_buf = ipc_buf;
+	ctx->ipc_hdl = hdl;
+
+	return 0;
+}
+
+static int delta_mjpeg_ipc_decode(struct delta_ctx *pctx, struct delta_au *au)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+	int ret = 0;
+	struct jpeg_decode_params_t *params = ctx->ipc_buf->vaddr;
+	struct jpeg_decode_return_params_t *status =
+	    ctx->ipc_buf->vaddr + sizeof(*params);
+	struct delta_frame *frame;
+	struct delta_ipc_param ipc_param, ipc_status;
+
+	ret = delta_get_free_frame(pctx, &frame);
+	if (ret)
+		return ret;
+
+	memset(params, 0, sizeof(*params));
+
+	params->picture_start_addr_p = (u32)(au->paddr);
+	params->picture_end_addr_p = (u32)(au->paddr + au->size - 1);
+
+	/* !WARNING!
+	 * the NV12 decoded frame is only available
+	 * on decimated output when enabling flag
+	 * "JPEG_ADDITIONAL_FLAG_420MB"...
+	 * the non decimated output gives YUV422SP
+	 */
+	params->main_aux_enable = JPEG_DISP_AUX_EN;
+	params->additional_flags = JPEG_ADDITIONAL_FLAG_420MB;
+	params->horizontal_decimation_factor = JPEG_HDEC_1;
+	params->vertical_decimation_factor = JPEG_VDEC_1;
+	params->decoding_mode = JPEG_NORMAL_DECODE;
+
+	params->display_buffer_addr.struct_size =
+	    sizeof(struct jpeg_display_buffer_address_t);
+	params->display_buffer_addr.display_decimated_luma_p =
+	    (u32)frame->paddr;
+	params->display_buffer_addr.display_decimated_chroma_p =
+	    (u32)(frame->paddr
+		  + frame->pix.width * frame->pix.height);
+
+	dev_vdbg(delta->dev,
+		 "%s  %s\n", pctx->name,
+		 ipc_decode_param_str(params, ctx->str, sizeof(ctx->str)));
+
+	ipc_param.size = sizeof(*params);
+	ipc_param.data = params;
+	ipc_status.size = sizeof(*status);
+	ipc_status.data = status;
+	ret = delta_ipc_decode(ctx->ipc_hdl, &ipc_param, &ipc_status);
+	if (ret) {
+		dev_err(delta->dev,
+			"%s  dumping command %s\n", pctx->name,
+			ipc_decode_param_str(params, ctx->str,
+					     sizeof(ctx->str)));
+		return ret;
+	}
+
+	pctx->decoded_frames++;
+
+	/* check firmware decoding status */
+	delta_mjpeg_check_status(pctx, status);
+
+	frame->pix.field = V4L2_FIELD_NONE;
+	frame->flags = V4L2_BUF_FLAG_KEYFRAME;
+	frame->state |= DELTA_FRAME_DEC;
+
+	ctx->out_frame = frame;
+
+	return 0;
+}
+
+static int delta_mjpeg_open(struct delta_ctx *pctx)
+{
+	struct delta_mjpeg_ctx *ctx;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	pctx->priv = ctx;
+
+	return 0;
+}
+
+static int delta_mjpeg_close(struct delta_ctx *pctx)
+{
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+
+	if (ctx->ipc_hdl) {
+		delta_ipc_close(ctx->ipc_hdl);
+		ctx->ipc_hdl = NULL;
+	}
+
+	kfree(ctx);
+
+	return 0;
+}
+
+static int delta_mjpeg_get_streaminfo(struct delta_ctx *pctx,
+				      struct delta_streaminfo *streaminfo)
+{
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+
+	if (!ctx->header)
+		goto nodata;
+
+	streaminfo->streamformat = V4L2_PIX_FMT_MJPEG;
+	streaminfo->width = ctx->header->frame_width;
+	streaminfo->height = ctx->header->frame_height;
+
+	/* 32 pixels aligned */
+	streaminfo->frame_width = (streaminfo->width + 31) & ~31;
+	streaminfo->frame_height = (streaminfo->height + 31) & ~31;
+
+	/* progressive stream */
+	streaminfo->field = V4L2_FIELD_NONE;
+
+	streaminfo->dpb = 1;
+
+	return 0;
+
+nodata:
+	return -ENODATA;
+}
+
+static int delta_mjpeg_decode(struct delta_ctx *pctx, struct delta_au *pau)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+	int ret;
+	struct delta_au au = *pau;
+	unsigned int data_offset;
+	struct mjpeg_header *header = &ctx->header_struct;
+
+	if (!ctx->header) {
+		ret = delta_mjpeg_read_header(pctx, au.vaddr, au.size,
+					      header, &data_offset);
+		if (ret) {
+			pctx->stream_errors++;
+			goto err;
+		}
+		if (header->frame_width * header->frame_height >
+		    DELTA_MJPEG_MAX_RESO) {
+			dev_err(delta->dev,
+				"%s  stream resolution too large: %dx%d > %d pixels budget\n",
+				pctx->name,
+				header->frame_width,
+				header->frame_height, DELTA_MJPEG_MAX_RESO);
+			ret = -EINVAL;
+			goto err;
+		}
+		ctx->width = header->frame_width;
+		ctx->height = header->frame_height;
+		ctx->header = header;
+		goto out;
+	}
+
+	if (!ctx->ipc_hdl) {
+		ret = delta_mjpeg_ipc_open(pctx);
+		if (ret)
+			goto err;
+	}
+
+	ret = delta_mjpeg_read_header(pctx, au.vaddr, au.size,
+				      ctx->header, &data_offset);
+	if (ret) {
+		pctx->stream_errors++;
+		goto err;
+	}
+
+	au.paddr += data_offset;
+	au.vaddr += data_offset;
+
+	ret = delta_mjpeg_ipc_decode(pctx, &au);
+	if (ret)
+		goto err;
+
+out:
+	return 0;
+
+err:
+	return ret;
+}
+
+static int delta_mjpeg_get_frame(struct delta_ctx *pctx,
+				 struct delta_frame **frame)
+{
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+
+	if (!ctx->out_frame)
+		return -ENODATA;
+
+	*frame = ctx->out_frame;
+
+	ctx->out_frame = NULL;
+
+	return 0;
+}
+
+static void delta_mjpeg_recycle(struct delta_ctx *pctx,
+				struct delta_frame *frame)
+{
+	frame->state &= ~DELTA_FRAME_DEC;
+
+	delta_recycle(pctx, frame);
+}
+
+static void delta_mjpeg_flush(struct delta_ctx *pctx)
+{
+}
+
+static void delta_mjpeg_drain(struct delta_ctx *pctx)
+{
+}
+
+const struct delta_dec mjpegdec = {
+	.name = "MJPEG",
+	.streamformat = V4L2_PIX_FMT_MJPEG,
+	.pixelformat = V4L2_PIX_FMT_NV12,
+	.open = delta_mjpeg_open,
+	.close = delta_mjpeg_close,
+	.get_streaminfo = delta_mjpeg_get_streaminfo,
+	.decode = delta_mjpeg_decode,
+	.setup_frame = delta_setup_frame,
+	.get_frame = delta_mjpeg_get_frame,
+	.recycle = delta_mjpeg_recycle,
+	.flush = delta_mjpeg_flush,
+	.drain = delta_mjpeg_drain,
+};
diff --git a/drivers/media/platform/sti/delta/delta-mjpeg-fw.h b/drivers/media/platform/sti/delta/delta-mjpeg-fw.h
new file mode 100644
index 0000000..f06d3de
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mjpeg-fw.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_MJPEG_FW_H
+#define DELTA_MJPEG_FW_H
+
+/* jpeg firmware version */
+#define JPEGHW_MME_VERSION	16
+
+/*
+ * struct jpeg_decoded_buffer_address_t
+ *
+ * defines the addresses where the decoded picture/additional
+ * info related to the block structures will be stored
+ *
+ * @display_luma_p:		address of the luma buffer
+ * @display_chroma_p:		address of the chroma buffer
+ */
+struct jpeg_decoded_buffer_address_t {
+	u32 luma_p;
+	u32 chroma_p;
+};
+
+/*
+ * struct jpeg_display_buffer_address_t
+ *
+ * defines the addresses (used by the Display Reconstruction block)
+ * where the pictures to be displayed will be stored
+ *
+ * @struct_size:		size of the structure in bytes
+ * @display_luma_p:		address of the luma buffer
+ * @display_chroma_p:		address of the chroma buffer
+ * @display_decimated_luma_p:	address of the decimated luma buffer
+ * @display_decimated_chroma_p:	address of the decimated chroma buffer
+ */
+struct jpeg_display_buffer_address_t {
+	u32 struct_size;
+	u32 display_luma_p;
+	u32 display_chroma_p;
+	u32 display_decimated_luma_p;
+	u32 display_decimated_chroma_p;
+};
+
+/* used for enabling main/aux outputs for both display &
+ * reference reconstruction blocks
+ */
+enum jpeg_rcn_ref_disp_enable_t {
+	/* enable decimated (for display) reconstruction */
+	JPEG_DISP_AUX_EN = 0x00000010,
+	/* enable main (for display) reconstruction */
+	JPEG_DISP_MAIN_EN = 0x00000020,
+	/* enable both main & decimated (for display) reconstruction */
+	JPEG_DISP_AUX_MAIN_EN = 0x00000030,
+	/* enable only reference output(ex. for trick modes) */
+	JPEG_REF_MAIN_EN = 0x00000100,
+	/* enable reference output with decimated
+	 * (for display) reconstruction
+	 */
+	JPEG_REF_MAIN_DISP_AUX_EN = 0x00000110,
+	/* enable reference output with main
+	 * (for display) reconstruction
+	 */
+	JPEG_REF_MAIN_DISP_MAIN_EN = 0x00000120,
+	/* enable reference output with main & decimated
+	 * (for display) reconstruction
+	 */
+	JPEG_REF_MAIN_DISP_MAIN_AUX_EN = 0x00000130
+};
+
+/* identifies the horizontal decimation factor */
+enum jpeg_horizontal_deci_factor_t {
+	/* no resize */
+	JPEG_HDEC_1 = 0x00000000,
+	/* Advanced H/2 resize using improved 8-tap filters */
+	JPEG_HDEC_ADVANCED_2 = 0x00000101,
+	/* Advanced H/4 resize using improved 8-tap filters */
+	JPEG_HDEC_ADVANCED_4 = 0x00000102
+};
+
+/* identifies the vertical decimation factor */
+enum jpeg_vertical_deci_factor_t {
+	/* no resize */
+	JPEG_VDEC_1 = 0x00000000,
+	/* V/2 , progressive resize */
+	JPEG_VDEC_ADVANCED_2_PROG = 0x00000204,
+	/* V/2 , interlaced resize */
+	JPEG_VDEC_ADVANCED_2_INT = 0x000000208
+};
+
+/* status of the decoding process */
+enum jpeg_decoding_error_t {
+	JPEG_DECODER_NO_ERROR = 0,
+	JPEG_DECODER_UNDEFINED_HUFF_TABLE = 1,
+	JPEG_DECODER_UNSUPPORTED_MARKER = 2,
+	JPEG_DECODER_UNABLE_ALLOCATE_MEMORY = 3,
+	JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS = 4,
+	JPEG_DECODER_BAD_PARAMETER = 5,
+	JPEG_DECODER_DECODE_ERROR = 6,
+	JPEG_DECODER_BAD_RESTART_MARKER = 7,
+	JPEG_DECODER_UNSUPPORTED_COLORSPACE = 8,
+	JPEG_DECODER_BAD_SOS_SPECTRAL = 9,
+	JPEG_DECODER_BAD_SOS_SUCCESSIVE = 10,
+	JPEG_DECODER_BAD_HEADER_LENGTH = 11,
+	JPEG_DECODER_BAD_COUNT_VALUE = 12,
+	JPEG_DECODER_BAD_DHT_MARKER = 13,
+	JPEG_DECODER_BAD_INDEX_VALUE = 14,
+	JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES = 15,
+	JPEG_DECODER_BAD_QUANT_TABLE_LENGTH = 16,
+	JPEG_DECODER_BAD_NUMBER_QUANT_TABLES = 17,
+	JPEG_DECODER_BAD_COMPONENT_COUNT = 18,
+	JPEG_DECODER_DIVIDE_BY_ZERO_ERROR = 19,
+	JPEG_DECODER_NOT_JPG_IMAGE = 20,
+	JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE = 21,
+	JPEG_DECODER_UNSUPPORTED_SCALING = 22,
+	JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE = 23,
+	JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE = 24,
+	JPEG_DECODER_BAD_VALUE_FROM_RED = 25,
+	JPEG_DECODER_BAD_SUBREGION_PARAMETERS = 26,
+	JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED = 27,
+	JPEG_DECODER_ERROR_TASK_TIMEOUT = 28
+};
+
+/* identifies the decoding mode */
+enum jpeg_decoding_mode_t {
+	JPEG_NORMAL_DECODE = 0,
+};
+
+enum jpeg_additional_flags_t {
+	JPEG_ADDITIONAL_FLAG_NONE = 0,
+	/* request firmware to return values of the CEH registers */
+	JPEG_ADDITIONAL_FLAG_CEH = 1,
+	/* output storage of auxiliary reconstruction in Raster format. */
+	JPEG_ADDITIONAL_FLAG_RASTER = 64,
+	/* output storage of auxiliary reconstruction in 420MB format. */
+	JPEG_ADDITIONAL_FLAG_420MB = 128
+};
+
+/*
+ * struct jpeg_video_decode_init_params_t - initialization command parameters
+ *
+ * @circular_buffer_begin_addr_p:	start address of fw circular buffer
+ * @circular_buffer_end_addr_p:		end address of fw circular buffer
+ */
+struct jpeg_video_decode_init_params_t {
+	u32 circular_buffer_begin_addr_p;
+	u32 circular_buffer_end_addr_p;
+};
+
+/*
+ * struct jpeg_decode_params_t - decode command parameters
+ *
+ * @picture_start_addr_p:	start address of jpeg picture
+ * @picture_end_addr_p:		end address of jpeg picture
+ * @decoded_buffer_addr:	decoded picture buffer
+ * @display_buffer_addr:	display picture buffer
+ * @main_aux_enable:		enable main and/or aux outputs
+ * @horizontal_decimation_factor:horizontal decimation factor
+ * @vertical_decimation_factor:	vertical decimation factor
+ * @xvalue0:			the x(0) coordinate for subregion decoding
+ * @xvalue1:			the x(1) coordinate for subregion decoding
+ * @yvalue0:			the y(0) coordinate for subregion decoding
+ * @yvalue1:			the y(1) coordinate for subregion decoding
+ * @decoding_mode:		decoding mode
+ * @additional_flags:		additional flags
+ * @field_flag:			determines frame/field scan
+ */
+struct jpeg_decode_params_t {
+	u32 picture_start_addr_p;
+	u32 picture_end_addr_p;
+	struct jpeg_decoded_buffer_address_t decoded_buffer_addr;
+	struct jpeg_display_buffer_address_t display_buffer_addr;
+	enum jpeg_rcn_ref_disp_enable_t main_aux_enable;
+	enum jpeg_horizontal_deci_factor_t horizontal_decimation_factor;
+	enum jpeg_vertical_deci_factor_t vertical_decimation_factor;
+	u32 xvalue0;
+	u32 xvalue1;
+	u32 yvalue0;
+	u32 yvalue1;
+	enum jpeg_decoding_mode_t decoding_mode;
+	u32 additional_flags;
+	u32 field_flag;
+};
+
+/*
+ * struct jpeg_decode_return_params_t
+ *
+ * status returned by firmware after decoding
+ *
+ * @decode_time_in_us:	decoding time in microseconds
+ * @pm_cycles:		profiling information
+ * @pm_dmiss:		profiling information
+ * @pm_imiss:		profiling information
+ * @pm_bundles:		profiling information
+ * @pm_pft:		profiling information
+ * @error_code:		status of the decoding process
+ * @ceh_registers:	array where values of the Contrast Enhancement
+ *			Histogram (CEH) registers will be stored.
+ *			ceh_registers[0] correspond to register MBE_CEH_0_7,
+ *			ceh_registers[1] correspond to register MBE_CEH_8_15
+ *			ceh_registers[2] correspond to register MBE_CEH_16_23
+ *			Note that elements of this array will be updated only
+ *			if additional_flags has JPEG_ADDITIONAL_FLAG_CEH set.
+ */
+struct jpeg_decode_return_params_t {
+	/* profiling info */
+#if (JPEGHW_MME_VERSION >= 17)
+	u32 decode_time_in_us;
+#endif
+	u32 pm_cycles;
+	u32 pm_dmiss;
+	u32 pm_imiss;
+	u32 pm_bundles;
+	u32 pm_pft;
+	enum jpeg_decoding_error_t error_code;
+	u32 ceh_registers[32];
+};
+
+#endif /* DELTA_MJPEG_FW_H */
diff --git a/drivers/media/platform/sti/delta/delta-mjpeg-hdr.c b/drivers/media/platform/sti/delta/delta-mjpeg-hdr.c
new file mode 100644
index 0000000..a77478a
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mjpeg-hdr.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2013
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "delta.h"
+#include "delta-mjpeg.h"
+
+#define MJPEG_SOF_0                             0xc0
+#define MJPEG_SOF_1                             0xc1
+#define MJPEG_SOI                               0xd8
+#define MJPEG_MARKER                            0xff
+
+static inline unsigned int __swapbw(unsigned int a)
+{
+	unsigned int tmp1 = (a << 8) & 0xFF00FF00;
+	unsigned int tmp2 = (a >> 8) & 0x00FF00FF;
+	unsigned int tmp3 = tmp1 | tmp2;
+
+	return ((tmp3 >> 16) | (tmp3 << 16));
+}
+
+static inline void bits_init(struct bits *bits)
+{
+	memset(bits, 0, sizeof(*bits));
+}
+
+void bits_set_ptr(struct bits *bits, unsigned char *ptr)
+{
+	unsigned int addr = (unsigned int)ptr;
+
+	bits->data = (unsigned int *)(addr & 0xfffffffc);
+	bits->available = 32 - ((addr & 0x3) * 8);
+	bits->word = __swapbw(*(bits->data++));
+}
+
+/* get and flush some bits */
+unsigned int bits_get(struct bits *bits, unsigned int N)
+{
+	/* ensure we have enough data */
+	if (bits->available < N) {
+		bits->word = (bits->word << 32) | __swapbw(*(bits->data++));
+		bits->available += 32;
+	}
+
+	/* return the appropriate field */
+	bits->available -= N;
+	return (bits->word >> bits->available) & ((1ULL << N) - 1);
+}
+
+static char *header_str(struct mjpeg_header *header,
+			char *str,
+			unsigned int len)
+{
+	unsigned int i;
+	char *cur = str;
+	unsigned int left = len;
+	unsigned int cnt;
+	int ret = 0;
+
+	if (!header)
+		return "";
+
+	ret = snprintf(cur, left, "[MJPEG header]\n"
+			"|- length    = %d\n"
+			"|- precision = %d\n"
+			"|- width     = %d\n"
+			"|- height    = %d\n"
+			"|- [components(%d)]\n",
+			header->length,
+			header->sample_precision,
+			header->frame_width,
+			header->frame_height,
+			header->number_of_components);
+	cnt = (left > ret ? ret : left);
+
+	for (i = 0; i < header->number_of_components; i++) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left,
+			       "   [%d]\n"
+			       "   |- h samp factor     = %d\n"
+			       "   |- v samp factor     = %d\n"
+			       "   |- quant table index = %d\n",
+			       header->components[i].id,
+			       header->components[i].h_sampling_factor,
+			       header->components[i].v_sampling_factor,
+			       header->components[i].quant_table_index);
+		cnt = (left > ret ? ret : left);
+	}
+
+	return str;
+}
+
+int delta_mjpeg_read_sof(struct delta_ctx *pctx,
+			 unsigned char *data, unsigned int size,
+			 struct mjpeg_header *header)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+	struct bits *bits = &ctx->bits;
+	unsigned int offset = 0;
+	unsigned int i = 0;
+
+	bits_init(bits);
+	bits_set_ptr(bits, data);
+
+	if (size < 64)
+		goto err_no_more;
+
+	memset(header, 0, sizeof(*header));
+	header->length                              = bits_get(bits, 16);
+	header->sample_precision                    = bits_get(bits, 8);
+	header->frame_height                        = bits_get(bits, 16);
+	header->frame_width                         = bits_get(bits, 16);
+	header->number_of_components                = bits_get(bits, 8);
+
+	offset += 64;
+
+	if (header->number_of_components >= MJPEG_MAX_COMPONENTS) {
+		dev_err(delta->dev,
+			"%s   unsupported number of components (> %d)\n",
+			pctx->name, MJPEG_MAX_COMPONENTS);
+		dev_err(delta->dev,
+			"%s", header_str(header, ctx->str, sizeof(ctx->str)));
+		return -EINVAL;
+	}
+
+	if ((offset + header->number_of_components *
+		sizeof(header->components[0])) > size)
+		goto err_no_more;
+
+	for (i = 0; i < header->number_of_components; i++) {
+		header->components[i].id = bits_get(bits, 8);
+		header->components[i].v_sampling_factor = bits_get(bits, 4);
+		header->components[i].h_sampling_factor = bits_get(bits, 4);
+		header->components[i].quant_table_index = bits_get(bits, 8);
+	}
+
+	return 0;
+
+err_no_more:
+	dev_err(delta->dev,
+		"%s   sof: reached end of %d size input stream\n",
+		pctx->name, size);
+	return -ENODATA;
+}
+
+int delta_mjpeg_read_header(struct delta_ctx *pctx,
+			    unsigned char *data, unsigned int size,
+			    struct mjpeg_header *header,
+			    unsigned int *data_offset)
+{
+	struct delta_dev *delta = pctx->dev;
+	struct delta_mjpeg_ctx *ctx = to_ctx(pctx);
+
+	unsigned int ret = 0;
+	unsigned int offset = 0;
+	unsigned int soi = 0;
+
+	if (size < 2)
+		goto err_no_more;
+
+	offset = 0;
+	while (1) {
+		if (data[offset] == MJPEG_MARKER)
+			switch (data[offset + 1]) {
+			case MJPEG_SOI:
+				soi = 1;
+				*data_offset = offset;
+			break;
+			case MJPEG_SOF_0:
+			case MJPEG_SOF_1:
+				if (!soi) {
+					dev_err(delta->dev,
+						"%s   wrong sequence, got SOF while SOI not seen\n",
+						pctx->name);
+					return -EINVAL;
+				}
+				ret = delta_mjpeg_read_sof(pctx,
+							   &data[offset + 2],
+							   size - (offset + 2),
+							   header);
+				if (ret)
+					goto err;
+				goto done;
+			break;
+			default:
+			break;
+			}
+
+		offset++;
+		if ((offset + 2) >= size)
+			goto err_no_more;
+	}
+
+done:
+	dev_dbg(delta->dev,
+		"%s   found header @ offset %d:\n%s", pctx->name,
+		*data_offset,
+		header_str(header, ctx->str, sizeof(ctx->str)));
+	return 0;
+
+err_no_more:
+	dev_err(delta->dev,
+		"%s   no header found within %d bytes input stream\n",
+		pctx->name, size);
+	return -ENODATA;
+
+err:
+	return ret;
+}
diff --git a/drivers/media/platform/sti/delta/delta-mjpeg.h b/drivers/media/platform/sti/delta/delta-mjpeg.h
new file mode 100644
index 0000000..6efac70
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-mjpeg.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2013
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_MJPEG_H
+#define DELTA_MJPEG_H
+
+#include "delta-mjpeg-fw.h"
+#include "delta.h"
+#include "delta-cfg.h"
+
+struct bits {
+	unsigned int available;
+	unsigned long long word;
+	unsigned int *data;
+};
+
+struct mjpeg_component {
+	unsigned int id;/* 1=Y, 2=Cb, 3=Cr, 4=L, 5=Q */
+	unsigned int h_sampling_factor;
+	unsigned int v_sampling_factor;
+	unsigned int quant_table_index;
+};
+
+#define MJPEG_MAX_COMPONENTS 5
+
+struct mjpeg_header {
+	unsigned int length;
+	unsigned int sample_precision;
+	unsigned int frame_width;
+	unsigned int frame_height;
+	unsigned int number_of_components;
+	struct mjpeg_component components[MJPEG_MAX_COMPONENTS];
+};
+
+struct delta_mjpeg_ctx {
+	/* bitstream */
+	struct bits bits;
+	struct mjpeg_header header_struct;
+	struct mjpeg_header *header;
+
+	/* ipc */
+	void *ipc_hdl;
+	struct delta_buf *ipc_buf;
+
+	__u32 width;
+	__u32 height;
+
+	struct delta_frame *out_frame;
+
+	unsigned char str[3000];
+};
+
+#define to_ctx(ctx) ((struct delta_mjpeg_ctx *)ctx->priv)
+
+int delta_mjpeg_read_header(struct delta_ctx *pctx,
+			    unsigned char *data, unsigned int size,
+			    struct mjpeg_header *header,
+			    unsigned int *data_offset);
+
+#endif /* DELTA_MJPEG_H */
diff --git a/drivers/media/platform/sti/delta/delta-v4l2.c b/drivers/media/platform/sti/delta/delta-v4l2.c
new file mode 100644
index 0000000..73165e3
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta-v4l2.c
@@ -0,0 +1,1838 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Jean-Christophe Trotin <jean-christophe.trotin@st.com>
+ *          for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "delta.h"
+#include "delta-debug.h"
+#include "delta-ipc.h"
+
+#define DELTA_NAME	"delta"
+
+#define to_ctx(__fh) container_of(__fh, struct delta_ctx, fh)
+#define to_vb2q(ctx, type) (type == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \
+				&ctx->q_aus : &ctx->q_frames)
+#define to_au(vb) ((struct delta_au *)vb)
+#define to_frame(vb) ((struct delta_frame *)vb)
+#define to_type_str(type) (type == V4L2_BUF_TYPE_VIDEO_OUTPUT ? "au" : "frame")
+
+/* offset to differentiate OUTPUT/CAPTURE @mmap, cf delta_mmap/querybuf */
+#define MMAP_FRAME_OFFSET (TASK_SIZE / 2)
+
+/* registry of available decoders */
+const struct delta_dec *delta_decoders[] = {
+#ifdef CONFIG_VIDEO_STI_DELTA_MJPEG
+	&mjpegdec,
+#endif
+};
+
+static inline int frame_size(__u32 w, __u32 h, __u32 fmt)
+{
+	WARN_ON(fmt != V4L2_PIX_FMT_NV12);
+	return (w * h * 3) / 2;
+}
+
+static inline int frame_stride(__u32 w, __u32 fmt)
+{
+	WARN_ON(fmt != V4L2_PIX_FMT_NV12);
+	return w;/* in NV12, stride in bytes is width */
+}
+
+static char *dump_au(struct delta_au *au, unsigned char *str, unsigned int len)
+{
+	unsigned char *cur = str;
+	size_t left = len;
+	int cnt = 0;
+	int ret = 0;
+	unsigned int i;
+	__u32 size = 10;	/* dump first & last 10 bytes */
+	__u8 *data = (__u8 *)(au->vaddr);
+
+	if (au->size < size)
+		size = au->size;
+
+	cur += cnt;
+	left -= cnt;
+	ret = snprintf(cur, left, "au[%d] dts=%lld size=%d data=",
+		       au->vbuf.vb2_buf.index,
+		       au->dts, au->size);
+	cnt = (left > ret ? ret : left);
+
+	for (i = 0; i < size; i++) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left, "%.2x ", data[i]);
+		cnt = (left > ret ? ret : left);
+	}
+
+	cur += cnt;
+	left -= cnt;
+	ret = snprintf(cur, left, "... ");
+	cnt = (left > ret ? ret : left);
+
+	if (au->size > size)
+		for (i = (au->size - size); i < au->size; i++) {
+			cur += cnt;
+			left -= cnt;
+			ret = snprintf(cur, left, "%.2x ", data[i]);
+			cnt = (left > ret ? ret : left);
+		}
+
+	cur += cnt;
+	left -= cnt;
+	ret = snprintf(cur, left, "\n");
+	cnt = (left > ret ? ret : left);
+
+	return str;
+}
+
+static char *dump_frame(struct delta_frame *frame, unsigned char *str,
+			unsigned int len)
+{
+	unsigned char *cur = str;
+	size_t left = len;
+	int cnt = 0;
+	int ret = 0;
+	unsigned int i;
+	__u32 size = 10;	/* dump first 10 bytes */
+	__u8 *data = (__u8 *)(frame->vaddr);
+
+	if (frame->pix.sizeimage < size)
+		size = frame->pix.sizeimage;
+
+	cur += cnt;
+	left -= cnt;
+	ret = snprintf(cur, left, "frame[%d] dts=%lld type=%s data=",
+		       frame->index,
+		       frame->dts,
+		       frame_type_str(frame->flags));
+	cnt = (left > ret ? ret : left);
+
+	for (i = 0; i < size; i++) {
+		cur += cnt;
+		left -= cnt;
+		ret = snprintf(cur, left, "%.2x ", data[i]);
+		cnt = (left > ret ? ret : left);
+	}
+
+	cur += cnt;
+	left -= cnt;
+	ret = snprintf(cur, left, "...\n");
+	cnt = (left > ret ? ret : left);
+
+	return str;
+}
+
+static void delta_push_dts(struct delta_ctx *ctx, u64 val)
+{
+	struct delta_dts *dts;
+
+	dts = kzalloc(sizeof(*dts), GFP_KERNEL);
+	if (!dts)
+		return;
+
+	INIT_LIST_HEAD(&dts->list);
+
+	/* protected by global lock acquired
+	 * by V4L2 when calling delta_vb2_au_queue
+	 */
+	dts->val = val;
+	list_add_tail(&dts->list, &ctx->dts);
+}
+
+static void delta_pop_dts(struct delta_ctx *ctx, u64 *val)
+{
+	struct delta_dev *delta = ctx->dev;
+	struct delta_dts *dts;
+
+	/* protected by global lock acquired
+	 * by V4L2 when calling delta_vb2_au_queue
+	 */
+	if (list_empty(&ctx->dts)) {
+		dev_warn(delta->dev, "%s  no dts to pop ... output dts = 0\n",
+			 ctx->name);
+		*val = 0;
+		return;
+	}
+
+	dts = list_first_entry(&ctx->dts, struct delta_dts, list);
+	list_del(&dts->list);
+
+	*val = dts->val;
+
+	kfree(dts);
+}
+
+static void register_decoder(struct delta_dev *delta,
+			     const struct delta_dec *dec)
+{
+	/* those decoder ops are mandatory */
+	WARN_ON(!dec->open);
+	WARN_ON(!dec->close);
+	WARN_ON(!dec->setup_frame);
+	WARN_ON(!dec->get_streaminfo);
+	WARN_ON(!dec->decode);
+	WARN_ON(!dec->get_frame);
+	WARN_ON(!dec->recycle);
+	WARN_ON(!dec->flush);
+	WARN_ON(!dec->drain);
+
+	delta->decoders[delta->nb_of_decoders] = dec;
+	delta->nb_of_decoders++;
+
+	dev_info(delta->dev, "%s decoder registered\n", dec->name);
+}
+
+static void register_all(struct delta_dev *delta)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(delta_decoders); i++)
+		register_decoder(delta, delta_decoders[i]);
+}
+
+static void delta_vb2_lock(struct vb2_queue *q)
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+
+	mutex_lock(&delta->lock);
+}
+
+static void delta_vb2_unlock(struct vb2_queue *q)
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+
+	mutex_unlock(&delta->lock);
+}
+
+static int delta_querycap(struct file *file, void *priv,
+			  struct v4l2_capability *cap)
+{
+	struct delta_dev *delta = video_drvdata(file);
+
+	strlcpy(cap->driver, delta->pdev->name, sizeof(cap->driver));
+	strlcpy(cap->card, delta->pdev->name, sizeof(cap->card));
+
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 DELTA_NAME);
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int delta_enum_fmt_stream(struct file *file, void *fh,
+				 struct v4l2_fmtdesc *f)
+{
+	struct delta_dev *delta = video_drvdata(file);
+
+	if (unlikely(f->index >= delta->nb_of_decoders))
+		return -EINVAL;
+
+	/* pixel format */
+	f->pixelformat = delta->decoders[f->index]->streamformat;
+
+	snprintf(f->description, sizeof(f->description), "%4.4s",
+		 (char *)&f->pixelformat);
+
+	/* compressed */
+	f->flags = V4L2_FMT_FLAG_COMPRESSED;
+
+	return 0;
+}
+
+static bool is_supported_streamformat(struct delta_ctx *ctx,
+				      __u32 streamformat)
+{
+	struct delta_dev *delta = ctx->dev;
+	unsigned int i;
+
+	for (i = 0; i < delta->nb_of_decoders; i++)
+		if (delta->decoders[i] &&
+		    (delta->decoders[i]->streamformat == streamformat))
+				return true;
+
+	return false;
+}
+
+/* default stream format: HD MJPEG */
+#define DEFAULT_WIDTH  1920
+#define DEFAULT_HEIGHT 1080
+
+static const struct v4l2_pix_format default_stream = {
+		.width          = DEFAULT_WIDTH,
+		.height         = DEFAULT_HEIGHT,
+		.pixelformat    = V4L2_PIX_FMT_MJPEG,
+		.field          = V4L2_FIELD_NONE,
+		.bytesperline   = DELTA_MAX_AU_SIZE,
+		.sizeimage      = DELTA_MAX_AU_SIZE,
+		.colorspace     = V4L2_COLORSPACE_REC709,
+};
+
+static int delta_g_fmt_stream(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (ctx->state <= DELTA_STATE_WF_FORMAT) {
+		/* FIXME for compliance... */
+		pix->width = default_stream.width;
+		pix->height = default_stream.height;
+		pix->pixelformat = default_stream.pixelformat;
+		pix->bytesperline = default_stream.bytesperline;
+		pix->sizeimage = default_stream.sizeimage;
+		pix->field = default_stream.field;
+		pix->colorspace = default_stream.colorspace;
+		return 0;
+	}
+
+	/* compressed stream at input */
+	pix->width = ctx->width;
+	pix->height = ctx->height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = ctx->max_au_size;
+	pix->sizeimage = ctx->max_au_size;
+	pix->pixelformat = ctx->streamformat;
+
+	return 0;
+}
+
+static int delta_try_fmt_stream(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	/**** request validation ****/
+	/* stream */
+	if (!is_supported_streamformat(ctx, pix->pixelformat)) {
+		dev_dbg(delta->dev,
+			"%s V4L2 TRY_FMT(OUTPUT): unsupported format\n",
+			ctx->name);
+		goto def;
+	}
+
+	/* width/height */
+	if ((pix->width == 0) || (pix->height == 0) ||
+	    (pix->width * pix->height > DELTA_MAX_RESO)) {
+		dev_dbg(delta->dev,
+			"%s V4L2 TRY_FMT(OUTPUT): invalid resolution: (%dx%d) is 0 or > %d pixels budget\n",
+			ctx->name, pix->width, pix->height, DELTA_MAX_RESO);
+		goto def;
+	}
+
+	/* input buffer size */
+	if ((pix->sizeimage <= 0) || (pix->sizeimage > DELTA_MAX_AU_SIZE)) {
+		dev_dbg(delta->dev,
+			"%s V4L2 TRY_FMT(OUTPUT): invalid size: %d size (%dx%d) is 0 or > %d max size budget\n",
+			ctx->name,
+			pix->sizeimage,
+			pix->width, pix->height, DELTA_MAX_AU_SIZE);
+		goto def;
+	}
+
+def:
+	/* returns the current format parameters as VIDIOC_G_FMT does */
+	delta_g_fmt_stream(file, fh, f);
+
+	return 0;
+}
+
+static int delta_s_fmt_stream(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct delta_dec *dec = NULL;
+	int ret;
+	unsigned int i;
+
+	/**** request validation ****/
+	/* stream */
+	if (!is_supported_streamformat(ctx, pix->pixelformat)) {
+		dev_dbg(delta->dev,
+			"%s V4L2 S_FMT(OUTPUT): unsupported format\n",
+			ctx->name);
+		goto def;
+	}
+
+	/* width/height */
+	if ((pix->width == 0) || (pix->height == 0) ||
+	    (pix->width * pix->height > DELTA_MAX_RESO)) {
+		dev_err(delta->dev,
+			"%s V4L2 S_FMT(OUTPUT): invalid resolution: (%dx%d) is 0 or > %d pixels budget\n",
+			ctx->name, pix->width, pix->height, DELTA_MAX_RESO);
+		goto def;
+	}
+
+	/* input buffer size */
+	if ((pix->sizeimage <= 0) || (pix->sizeimage > DELTA_MAX_AU_SIZE)) {
+		dev_err(delta->dev,
+			"%s V4L2 S_FMT(OUTPUT): invalid size: %d size (%dx%d) is 0 or > %d max size budget\n",
+			ctx->name,
+			pix->sizeimage,
+			pix->width, pix->height, DELTA_MAX_AU_SIZE);
+		goto def;
+	}
+
+	/**** open decoder ****/
+	/* open expected ? */
+	if (ctx->state != DELTA_STATE_WF_FORMAT) {
+		dev_warn(delta->dev,
+			 "%s V4L2 S_FMT(OUTPUT): wrong state, got %d while DELTA_STATE_WF_FORMAT expected, ignoring...\n",
+			 ctx->name, ctx->state);
+		goto out;
+	}
+
+	/* find a decoder which can deal with this format */
+	for (i = 0; i < delta->nb_of_decoders; i++) {
+		dec = delta->decoders[i];
+		if (dec && (dec->streamformat == pix->pixelformat))
+			break;	/* found */
+	}
+
+	if (!dec) {
+		dev_err(delta->dev,
+			"%s no suitable decoder found for format=%4.4s and resolution %dx%d\n",
+			ctx->name,
+			(char *)&pix->pixelformat,
+			pix->width, pix->height);
+		return -EINVAL;
+	}
+
+	/* update name instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:%4s]", delta->instance_id,
+		 dec->name);
+
+	/* open decoder instance */
+	ret = dec->open(ctx);
+	if (ret) {
+		dev_err(delta->dev, "%s dec->open failed (%d)", ctx->name, ret);
+		return ret;
+	}
+
+	/* update context */
+	ctx->width = pix->width;	/* FIXME add a check in case of conflict
+					 * with already given width/height
+					 * from S_FMT(capture)
+					 */
+	ctx->height = pix->height;
+	ctx->streamformat = pix->pixelformat;
+	ctx->max_au_size = pix->sizeimage;
+	ctx->dec = dec;
+	ctx->state = DELTA_STATE_WF_STREAMINFO;
+
+def:
+	/* returns the current format parameters as VIDIOC_G_FMT does */
+	delta_g_fmt_stream(file, fh, f);
+
+out:
+	return 0;
+}
+
+int delta_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *b)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+
+	/* request validation */
+	if ((b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) &&
+	    (b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		dev_err(delta->dev,
+			"%s V4L2 REQBUFS: only V4L2_BUF_TYPE_VIDEO_OUTPUT/CAPTURE are supported\n",
+			ctx->name);
+		return -EINVAL;
+	}
+
+	/* vb2 call
+	 * will call delta_vb2_au_queue_setup or delta_vb2_frame_queue_setup
+	 */
+	return vb2_reqbufs(to_vb2q(ctx, b->type), b);
+}
+
+static int delta_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+	int ret;
+
+	/* request validation */
+	if ((b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) &&
+	    (b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		dev_err(delta->dev,
+			"%s V4L2 QUERYBUF: only V4L2_BUF_TYPE_VIDEO/CAPTURE are supported\n",
+			ctx->name);
+		return -EINVAL;
+	}
+
+	/* vb2 call */
+	ret = vb2_querybuf(to_vb2q(ctx, b->type), b);
+	if (ret)
+		return ret;
+
+	/* add an offset to differentiate OUTPUT/CAPTURE @mmap time */
+	if ((b->memory == V4L2_MEMORY_MMAP) &&
+	    (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		b->m.offset += MMAP_FRAME_OFFSET;
+	}
+
+	return 0;
+}
+
+static int delta_expbuf(struct file *file, void *fh,
+			struct v4l2_exportbuffer *b)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	/* vb2 call */
+	return vb2_expbuf(to_vb2q(ctx, b->type), b);
+}
+
+static int delta_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	/* vb2 call
+	 * will call delta_vb2_au_queue or delta_vb2_frame_queue
+	 */
+	return vb2_qbuf(to_vb2q(ctx, b->type), b);
+}
+
+static int delta_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	/* vb2 call
+	 * will call delta_vb2_au_queue or
+	 * delta_vb2_frame_start_streaming & delta_vb2_frame_queue
+	 */
+	return vb2_streamon(to_vb2q(ctx, i), i);
+}
+
+static int delta_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	/* vb2 call
+	 * will return au or frame buffers returned through vb2_buffer_done()
+	 */
+	return vb2_dqbuf(to_vb2q(ctx, b->type), b, file->f_flags & O_NONBLOCK);
+}
+
+static int delta_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	/* vb2 call
+	 * will call delta_vb2_au_stop_streaming or
+	 * delta_vb2_frame_stop_streaming
+	 */
+	return vb2_streamoff(to_vb2q(ctx, i), i);
+}
+
+static int delta_vb2_au_queue_setup(struct vb2_queue *q,
+				    unsigned int *num_buffers,
+				    unsigned int *num_planes,
+				    unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+
+	*num_planes = 1;
+	if (*num_buffers < 1)
+		*num_buffers = 1;
+	if (*num_buffers > DELTA_MAX_AUS)
+		*num_buffers = DELTA_MAX_AUS;
+
+	if (sizes[0])
+		dev_warn(delta->dev, "%s psize[0] already set to %d\n",
+			 ctx->name, sizes[0]);
+
+	if (alloc_ctxs[0])
+		dev_warn(delta->dev, "%s allocators[0] already set\n",
+			 ctx->name);
+
+	if (ctx->max_au_size <= 0) {
+		dev_err(delta->dev,
+			"%s ctx->max_au_size is 0, verify S_FMT(OUTPUT, sizeimage)\n",
+			ctx->name);
+		ctx->max_au_size = DELTA_MAX_AU_SIZE;
+	}
+
+	sizes[0] = ctx->max_au_size;
+
+	/* free @ release */
+	alloc_ctxs[0] = vb2_dma_contig_init_ctx(delta->dev);
+
+	return 0;
+}
+
+static int delta_vb2_au_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+	struct delta_au *au = to_au(vb);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	if (!au->prepared) {
+		/* get memory addresses */
+		au->vaddr = vb2_plane_vaddr(&au->vbuf.vb2_buf, 0);
+		au->paddr = vb2_dma_contig_plane_dma_addr(&au->vbuf.vb2_buf, 0);
+
+		au->state = DELTA_AU_FREE;
+		ctx->aus[vb->index] = au;
+		ctx->nb_of_aus++;
+
+		au->prepared = 1;
+		dev_dbg(delta->dev, "%s au[%d] prepared; virt=%p, phy=%x\n",
+			ctx->name, vb->index, au->vaddr, au->paddr);
+	}
+
+	/* update au size (from user) */
+	au->size = vb2_get_plane_payload(vb, 0);
+
+	au->dts = vb->timestamp;
+	return 0;
+}
+
+static void delta_au_done(struct delta_ctx *ctx, struct delta_au *au, int err)
+{
+	if (au->state & DELTA_AU_OUT)
+		return;
+
+	au->state |= DELTA_AU_OUT;
+	vb2_buffer_done(&au->vbuf.vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+}
+
+static void delta_frame_done(struct delta_ctx *ctx, struct delta_frame *frame,
+			     int err)
+{
+	struct delta_dev *delta = ctx->dev;
+	unsigned char str[100] = "";
+
+	/* dump frame */
+	dev_dbg(delta->dev, "%s dump %s", ctx->name,
+		dump_frame(frame, str, sizeof(str)));
+
+	/* decoded frame is now output to user */
+	frame->state |= DELTA_FRAME_OUT;
+
+	vb2_buffer_done(&frame->vbuf.vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	ctx->output_frames++;
+}
+
+int delta_setup_frame(struct delta_ctx *ctx,
+		      struct delta_frame *frame)
+{
+	struct delta_dev *delta = ctx->dev;
+
+	if (frame->index >= sizeof(ctx->frames)) {
+		dev_err(delta->dev,
+			"%s  frame index=%d exceeds output frame count (%d)\n",
+			ctx->name,
+			frame->index,
+			sizeof(ctx->frames));
+		return -EINVAL;
+	}
+
+	frame->state = DELTA_FRAME_FREE;
+	ctx->frames[frame->index] = frame;
+	ctx->nb_of_frames++;
+
+	return 0;
+}
+
+static void dump_frames_status(struct delta_ctx *ctx)
+{
+	struct delta_dev *delta = ctx->dev;
+	unsigned int i;
+	unsigned char str[100] = "";
+
+	dev_info(delta->dev,
+		 "%s dumping frames status...\n", ctx->name);
+
+	for (i = 0; i < ctx->nb_of_frames; i++)
+		dev_info(delta->dev,
+			 "%s frame[%d] %s\n",
+			 ctx->name, i,
+			 frame_state_str(ctx->frames[i]->state,
+					 str, sizeof(str)));
+}
+
+static int delta_wait_recycle(struct delta_ctx *ctx)
+{
+	struct delta_dev *delta = ctx->dev;
+	int ret = 0;
+	bool closed = false;
+
+	/* block till out frames recycled */
+retry:
+	mutex_unlock(&delta->lock);	/* release global lock to let
+					 * throw qbuf(frame) or close() or
+					 * streamoff(frame)
+					 */
+	ret = wait_event_interruptible(ctx->wq_recycle,
+				       ((ctx->recycled_frames > 0) ||
+					(ctx->state == DELTA_STATE_STOPPED) ||
+					(closed =
+					 (ctx->state == DELTA_STATE_CLOSED))));
+
+	/* reacquire global lock */
+	mutex_lock(&delta->lock);
+
+	/* if closed, ctx is potentially free-ed at this point,
+	 * so exit without any ctx accesses
+	 */
+	if (closed)
+		return -EINTR;
+
+	/* we need to reevaluate conditions again after reacquiring
+	 * the lock or return an error if one occurred.
+	 */
+	if (ret < 0) {
+		/* interrupted */
+		dev_err(delta->dev,
+			"%s  interrupted while waiting for recycled frames (ret=%d)\n",
+			ctx->name, ret);
+
+		dump_frames_status(ctx);
+		goto err;
+	}
+	if (ctx->state == DELTA_STATE_STOPPED) {
+		/* stopping */
+		dev_dbg(delta->dev,
+			"%s  stopped while waiting for recycled frames\n",
+			ctx->name);
+		ret = -ENODATA;
+		goto err;
+	}
+	if (ctx->recycled_frames <= 0) {
+		/* no recycled frames, condition may have changed while
+		 * unlocked, retry
+		 */
+		dev_warn(delta->dev,
+			 "%s  exit of recycled frames wait point but no frames, retrying...\n",
+			 ctx->name);
+		goto retry;
+	}
+
+	/* Reinitialize exit condition for next call */
+	ctx->recycled_frames = 0;
+
+	return 0;
+
+err:
+	return ret;
+}
+
+int delta_get_free_frame(struct delta_ctx *ctx,
+			 struct delta_frame **pframe)
+{
+	struct delta_dev *delta = ctx->dev;
+	int ret = 0;
+	unsigned int i;
+	unsigned int found = 0;
+	struct delta_frame *frame;
+	unsigned int tries = 3;
+
+	*pframe = NULL;
+retry:
+	/* find a free frame */
+	for (i = 0; i < ctx->nb_of_frames; i++) {
+		if (ctx->frames[i]->state == DELTA_FRAME_FREE) {
+			frame = ctx->frames[i];
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		if (tries <= 0) {
+			dev_err(delta->dev,
+				"%s  no output frame available @ frame %d, access unit is dropped\n",
+				ctx->name,
+				ctx->decoded_frames);
+
+			dump_frames_status(ctx);
+			return -ETIMEDOUT;
+		}
+		tries--;
+
+		dev_dbg(delta->dev,
+			"%s  no output frame available, wait for recycle\n",
+			ctx->name);
+
+		/* block till frames recycled */
+		ret = delta_wait_recycle(ctx);
+		if (ret)
+			return ret;
+
+		/* unblocked, retry... */
+		goto retry;
+	}
+
+	*pframe = frame;
+	return 0;
+}
+
+void delta_recycle(struct delta_ctx *ctx,
+		   struct delta_frame *frame)
+{
+	/* this frame is no more output */
+	frame->state &= ~DELTA_FRAME_OUT;
+
+	/* reset other frame fields */
+	frame->flags = 0;
+	frame->dts = 0;
+
+	ctx->recycled_frames++;
+	wake_up(&ctx->wq_recycle);
+}
+
+int delta_get_sync(struct delta_ctx *ctx)
+{
+	struct delta_dev *delta = ctx->dev;
+	int ret = 0;
+
+	/* enable the hardware */
+	ret = pm_runtime_get_sync(delta->dev);
+	if (ret < 0) {
+		dev_err(delta->dev, "%s pm_runtime_get_sync failed (%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+void delta_put_autosuspend(struct delta_ctx *ctx)
+{
+	struct delta_dev *delta = ctx->dev;
+
+	pm_runtime_put_autosuspend(delta->dev);
+}
+
+static void delta_vb2_au_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+	const struct delta_dec *dec = ctx->dec;
+	struct delta_au *au = to_au(vb);
+	struct delta_frame *frame = NULL;
+	unsigned char str[100] = "";
+	int ret = 0;
+	bool discard = false;
+
+	au->state &= ~DELTA_AU_OUT;
+
+	if (ctx->state == DELTA_STATE_STOPPED)
+		goto out;
+
+	/* just ignore empty buffers.
+	 * this is needed when setting-up
+	 * input stream queue; they have been queued
+	 * by user with 0-size after each QUERYBUF,
+	 * and driver just have to ignore them
+	 * in order that they can be dequeued by user
+	 * later to put the stream access unit data.
+	 */
+	if (au->size == 0)
+		goto out;
+
+	/* avoid too large au size */
+	if (au->size > DELTA_MAX_AU_SIZE) {
+		dev_err(delta->dev,
+			"%s too large au size, got %d while less than %d expected\n",
+			ctx->name,
+			au->size, DELTA_MAX_AU_SIZE);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* update timestamp (from user) */
+	au->dts = vb->timestamp;
+
+	if (!dec) {
+		dev_err(delta->dev, "%s no decoder opened yet\n", ctx->name);
+		ret = -EIO;
+		goto err;
+	}
+
+	/* dump access unit */
+	dev_dbg(delta->dev, "%s dump %s", ctx->name,
+		dump_au(au, str, sizeof(str)));
+
+	ctx->recycled_frames = 0;
+
+	/* enable the hardware */
+	if (!dec->pm) {
+		ret = delta_get_sync(ctx);
+		if (ret)
+			goto err;
+	}
+
+	/* decode this access unit */
+	ret = dec->decode(ctx, au);
+
+	/* if interrupted, ctx is potentially free-ed at this point (closing
+	 * case), so exit right now without any ctx accesses
+	 */
+	if (ret == -EINTR)
+		return;
+
+	/* if stopped, return back current au to vb2 and return */
+	if (ctx->state == DELTA_STATE_STOPPED) {
+		/* disable the hardware */
+		if (!dec->pm)
+			delta_put_autosuspend(ctx);
+		goto out;
+	}
+
+	/* if the (-ENODATA) value is returned, it refers to the interlaced
+	 * stream case for which 2 access units are needed to get 1 frame.
+	 * So, this returned value doesn't mean that the decoding fails, but
+	 * indicates that the timestamp information of the access unit shall
+	 * not be taken into account, and that the V4L2 buffer associated with
+	 * the access unit shall be flagged with V4L2_BUF_FLAG_ERROR to inform
+	 * the user of this situation
+	 */
+	if (ret == -ENODATA) {
+		discard = true;
+	} else if (ret) {
+		dev_err(delta->dev, "%s dec->decode failed (%d)\n",
+			ctx->name, ret);
+
+		/* disable the hardware */
+		if (!dec->pm)
+			delta_put_autosuspend(ctx);
+
+		goto err;
+	}
+
+	/* disable the hardware */
+	if (!dec->pm)
+		delta_put_autosuspend(ctx);
+
+	/* get infos from stream if not yet done */
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO)) {
+		struct delta_streaminfo *streaminfo = &ctx->streaminfo;
+
+		ret = dec->get_streaminfo(ctx, streaminfo);
+		if (ret) {
+			/* infos not yet available, will retry on next stream
+			 * au enqueued till stream header decoded.
+			 * 2 valid cases can be encountered:
+			 * 1) live streaming; first enqueued au may not be
+			 *   the header, so each au must be decoded waiting
+			 *   for header
+			 * 2) corrupted or unsupported stream, in that case
+			 *   header may never been recognized. FIXME put
+			 *   in place a guard to not parse all bistream
+			 *   in that case (warn to conflict with case 1)) !
+			 */
+			dev_dbg_ratelimited(delta->dev,
+					    "%s valid stream header not yet discovered, more video stream needed to be enqueued\n",
+					    ctx->name);
+			goto out;
+		}
+		ctx->flags |= DELTA_FLAG_STREAMINFO;
+		ctx->state = DELTA_STATE_READY;
+
+		dev_info(delta->dev, "%s %s\n", ctx->name,
+			 delta_streaminfo_str(streaminfo, str, sizeof(str)));
+	}
+
+	/* push au timestamp in FIFO */
+	if (!discard)
+		delta_push_dts(ctx, au->dts);
+
+	/* get decoded frames available */
+	while (1) {
+		ret = dec->get_frame(ctx, &frame);
+		if (ret == -ENODATA) {
+			/* no more decoded frames */
+			goto out;
+		}
+		if (ret) {
+			dev_err(delta->dev, "%s  dec->get_frame failed (%d)\n",
+				ctx->name, ret);
+			goto out;
+		}
+		if (!frame) {
+			dev_err(delta->dev,
+				"%s  dec->get_frame returned NULL frame\n",
+				ctx->name);
+			ret = -EIO;
+			goto out;
+		}
+
+		/* pop timestamp and mark frame with it */
+		delta_pop_dts(ctx, &frame->dts);
+
+		/* release decoded frame to user */
+		delta_frame_done(ctx, frame, 0);
+	}
+
+out:
+	delta_au_done(ctx, au, (discard ? -ENODATA : 0));
+	return;
+
+err:
+	delta_au_done(ctx, au, ret);
+}
+
+static void delta_flush_dts(struct delta_ctx *ctx)
+{
+	struct delta_dts *dts;
+	struct delta_dts *next;
+
+	/* protected by global lock acquired
+	 * by V4L2 when calling delta_vb2_au_queue
+	 */
+
+	/* free all pending dts */
+	list_for_each_entry_safe(dts, next, &ctx->dts, list)
+		kfree(dts);
+
+	/* reset list */
+	INIT_LIST_HEAD(&ctx->dts);
+}
+
+static void delta_vb2_au_stop_streaming(struct vb2_queue *q)
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_au *au;
+	unsigned int i;
+
+	delta_flush_dts(ctx);
+
+	/* force return of all pending
+	 * buffers to vb2 (in error state)
+	 */
+	for (i = 0; i < ctx->nb_of_aus; i++) {
+		au = ctx->aus[i];
+		if (!(au->state & DELTA_AU_OUT)) {
+			au->state |= DELTA_AU_OUT;
+			vb2_buffer_done(&au->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);
+		}
+	}
+}
+
+static int delta_enum_fmt_frame(struct file *file, void *fh,
+				struct v4l2_fmtdesc *f)
+{
+	struct delta_dev *delta = video_drvdata(file);
+
+	if (unlikely(f->index >= delta->nb_of_decoders))
+		return -EINVAL;
+
+	/* frame pixel format */
+	f->pixelformat = DELTA_OUT_FMT_FOURCC;
+
+	snprintf(f->description, sizeof(f->description), "%4.4s",
+		 (char *)&f->pixelformat);
+
+	return 0;
+}
+
+/* default frame format: HD NV12 */
+#define DEFAULT_WIDTH  1920
+#define DEFAULT_HEIGHT 1080
+
+static const struct v4l2_pix_format default_frame = {
+		.width          = DEFAULT_WIDTH,
+		.height         = DEFAULT_HEIGHT,
+		.pixelformat    = V4L2_PIX_FMT_NV12,
+		.field          = V4L2_FIELD_NONE,
+		.bytesperline   = DEFAULT_WIDTH,
+		.sizeimage      = DEFAULT_WIDTH * DEFAULT_HEIGHT * 3 / 2,
+		.colorspace     = V4L2_COLORSPACE_REC709,
+};
+
+static int delta_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct delta_streaminfo *streaminfo = &ctx->streaminfo;
+
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO)) {
+		/* limit rate because of potential user polling on
+		 * availability while stream header is not yet recognized
+		 * by decoder
+		 */
+		dev_warn_ratelimited(delta->dev,
+				     "%s valid stream header not yet discovered, more video stream needed to be enqueued\n",
+				     ctx->name);
+
+		pix->width = default_frame.width;
+		pix->height = default_frame.height;
+		pix->pixelformat = default_frame.pixelformat;
+		pix->bytesperline = default_frame.bytesperline;
+		pix->sizeimage = default_frame.sizeimage;
+		pix->field = default_frame.field;
+		pix->colorspace = default_frame.colorspace;
+		return 0;
+	}
+
+	/* output uncompressed frame */
+	pix->width = streaminfo->frame_width;
+	pix->height = streaminfo->frame_height;
+	pix->pixelformat = DELTA_OUT_FMT_FOURCC;
+	pix->bytesperline = frame_stride(streaminfo->frame_width,
+					 pix->pixelformat);
+	pix->sizeimage = frame_size(streaminfo->frame_width,
+				    streaminfo->frame_height, pix->pixelformat);
+	pix->field = streaminfo->field;
+
+	return 0;
+}
+
+static int delta_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	/* returns the current format parameters as VIDIOC_G_FMT does */
+	return delta_g_fmt_frame(file, fh, f);
+}
+
+int delta_g_crop(struct file *file, void *fh, struct v4l2_crop *a)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+	struct delta_dev *delta = ctx->dev;
+	struct delta_streaminfo *streaminfo = &ctx->streaminfo;
+
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO)) {
+		/* limit rate because of potential user polling on
+		 * availability while stream header is not yet recognized
+		 * by decoder
+		 */
+		dev_warn_ratelimited(delta->dev,
+				     "%s valid stream header not yet discovered, more video stream needed to be enqueued\n",
+				     ctx->name);
+		return -EBUSY;
+	}
+
+	if (streaminfo->flags & DELTA_STREAMINFO_FLAG_CROP) {
+		a->c = streaminfo->crop;
+	} else {
+		/* default to video dimensions */
+		a->c.left = 0;
+		a->c.top = 0;
+		a->c.width = streaminfo->width;
+		a->c.height = streaminfo->height;
+	}
+
+	return 0;
+}
+
+static int delta_try_fmt_frame(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (pix->pixelformat != DELTA_OUT_FMT_FOURCC)
+		return -EINVAL;
+
+	if (pix->field != V4L2_FIELD_INTERLACED)
+		pix->field = V4L2_FIELD_NONE;
+
+	/* returns the current format parameters as VIDIOC_G_FMT does */
+	return delta_g_fmt_frame(file, fh, f);
+}
+
+static int delta_decoder_stop_cmd(struct delta_ctx *ctx, void *fh)
+{
+	const struct delta_dec *dec = ctx->dec;
+	struct delta_frame *frame = NULL;
+	int ret = 0;
+
+	if (!dec)
+		goto out;
+
+	/* drain the decoder */
+	dec->drain(ctx);
+
+	/* release to user drained frames */
+	while (1) {
+		frame = NULL;
+		ret = dec->get_frame(ctx, &frame);
+		if (ret == -ENODATA)
+			break; /* no more decoded frames */
+
+		if (frame) {
+			/* pop timestamp and mark frame with it */
+			delta_pop_dts(ctx, &frame->dts);
+
+			/* release decoded frame to user */
+			delta_frame_done(ctx, frame, 0);
+		}
+	}
+
+out:
+	/* EOS completion from driver is delayed because
+	 * at this point:
+	 * -  we don't know what is the last frame to be flagged
+	 *    as V4L2_BUF_FLAG_LAST
+	 * - and we are not sure to have a free empty frame available.
+	 *
+	 * EOS completion is so delayed till next frame_queue() call
+	 * to be sure to have a free empty frame available.
+	 */
+	ctx->state = DELTA_STATE_WF_EOS;
+
+	return ret;
+}
+
+int delta_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)
+{
+	struct delta_ctx *ctx = to_ctx(fh);
+
+	switch (cmd->cmd) {
+	case V4L2_DEC_CMD_STOP:
+		if (cmd->flags != 0)
+			return -EINVAL;
+
+		delta_decoder_stop_cmd(ctx, fh);
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int delta_subscribe_event(struct v4l2_fh *fh,
+				 const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 2, NULL);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int delta_vb2_frame_queue_setup(struct vb2_queue *q,
+				       unsigned int *num_buffers,
+				       unsigned int *num_planes,
+				       unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+	struct delta_streaminfo *streaminfo = &ctx->streaminfo;
+	__u32 frame_width;
+	__u32 frame_height;
+	__u32 dpb;
+
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO)) {
+		dev_warn_ratelimited(delta->dev,
+				     "%s valid stream header not yet discovered, more video stream needed to be enqueued\n",
+				     ctx->name);
+		frame_width = default_frame.width;
+		frame_height = default_frame.height;
+		dpb = 0;
+	} else {
+		frame_width = streaminfo->frame_width;
+		frame_height = streaminfo->frame_height;
+		dpb = streaminfo->dpb;
+	}
+
+	/* single plane for Y and CbCr */
+	*num_planes = 1;
+
+	/* the number of output buffers needed for decoding =
+	 * user need (*num_buffers given, usually for display pipeline) +
+	 * stream need (streaminfo->dpb) +
+	 * decoding peak smoothing (depends on DELTA IP perf)
+	 */
+	if (*num_buffers < DELTA_MIN_FRAME_USER) {
+		dev_warn(delta->dev,
+			 "%s num_buffers too low (%d), increasing to %d\n",
+			 ctx->name, *num_buffers, DELTA_MIN_FRAME_USER);
+		*num_buffers = DELTA_MIN_FRAME_USER;
+	}
+
+	*num_buffers += dpb + DELTA_PEAK_FRAME_SMOOTHING;
+
+	if (*num_buffers > DELTA_MAX_FRAMES) {
+		dev_warn(delta->dev,
+			 "%s Output frame count too high (%d), cut to %d\n",
+			 ctx->name, *num_buffers, DELTA_MAX_FRAMES);
+		*num_buffers = DELTA_MAX_FRAMES;
+	}
+
+	if (sizes[0])
+		dev_warn(delta->dev, "%s psize[0] already set to %d\n",
+			 ctx->name, sizes[0]);
+	if (alloc_ctxs[0])
+		dev_warn(delta->dev, "%s allocators[0] already set\n",
+			 ctx->name);
+
+	sizes[0] = frame_size(frame_width,
+			      frame_height, DELTA_OUT_FMT_FOURCC);
+	/* free-ed @ release */
+	alloc_ctxs[0] = vb2_dma_contig_init_ctx(delta->dev);
+
+	return 0;
+}
+
+static int delta_vb2_frame_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+	const struct delta_dec *dec = ctx->dec;
+	struct delta_frame *frame = to_frame(vb);
+	int ret = 0;
+	struct delta_streaminfo *streaminfo = &ctx->streaminfo;
+	__u32 frame_width;
+	__u32 frame_height;
+
+	if (!(ctx->flags & DELTA_FLAG_STREAMINFO)) {
+		dev_warn_ratelimited(delta->dev,
+				     "%s valid stream header not yet discovered, more video stream needed to be enqueued\n",
+				     ctx->name);
+		frame_width = default_frame.width;
+		frame_height = default_frame.height;
+	} else {
+		frame_width = streaminfo->frame_width;
+		frame_height = streaminfo->frame_height;
+	}
+
+	if (!frame->prepared) {
+		frame->index = frame->vbuf.vb2_buf.index;
+		frame->vaddr = vb2_plane_vaddr(&frame->vbuf.vb2_buf, 0);
+		frame->paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf.vb2_buf, 0);
+
+		frame->pix.width = frame_width;
+		frame->pix.height = frame_height;
+		frame->pix.pixelformat = DELTA_OUT_FMT_FOURCC;
+		frame->pix.bytesperline = frame_stride(frame->pix.width,
+						       frame->pix.pixelformat);
+		frame->pix.sizeimage = frame_size(frame->pix.width,
+						  frame->pix.height,
+						  frame->pix.pixelformat);
+		vb2_set_plane_payload(&frame->vbuf.vb2_buf, 0, frame->pix.sizeimage);
+
+		if (dec)
+			ret = dec->setup_frame(ctx, frame);
+		if (ret) {
+			dev_err(delta->dev,
+				"%s  dec->setup_frame failed (%d)\n",
+				ctx->name, ret);
+			return ret;
+		}
+		frame->prepared = 1;
+		dev_dbg(delta->dev,
+			"%s  frame[%d] prepared; virt=%p, phy=%x\n",
+			ctx->name, vb->index, frame->vaddr,
+			frame->paddr);
+	}
+
+	return 0;
+}
+
+static void delta_vb2_frame_finish(struct vb2_buffer *vb)
+{
+	struct delta_frame *frame = to_frame(vb);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	/* update V4L2 timestamp for user */
+	vb->timestamp = frame->dts;
+
+	/* update V4L2 field for user */
+	vbuf->field = frame->pix.field;
+
+	/* update V4L2 frame flags for user */
+	vbuf->flags = frame->flags;
+}
+
+static void delta_vb2_frame_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	struct delta_dev *delta = ctx->dev;
+	const struct delta_dec *dec = ctx->dec;
+	struct delta_frame *frame = to_frame(vb);
+
+	if (ctx->state == DELTA_STATE_WF_EOS) {
+		/* new frame available, EOS can now be completed:
+		 * - by returning an empty frame flagged to V4L2_BUF_FLAG_LAST
+		 * - and then send EOS event
+		 */
+		const struct v4l2_event ev = {
+				.type = V4L2_EVENT_EOS
+		};
+
+		/* set the last buffer flag */
+		frame->flags |= V4L2_BUF_FLAG_LAST;
+//		frame->vb2.v4l2_buf.bytesused = 0;//FIXME TBC
+		vb2_set_plane_payload(&frame->vbuf.vb2_buf, 0, 0);
+
+		/* release frame to user */
+		vb2_buffer_done(&frame->vbuf.vb2_buf, VB2_BUF_STATE_DONE);
+
+		v4l2_event_queue_fh(&ctx->fh, &ev);
+		dev_dbg(delta->dev, "%s EOS event queued\n",
+			ctx->name);
+		ctx->state = DELTA_STATE_EOS;
+
+		/* return, no need to recycle this buffer to decoder */
+		return;
+	}
+
+	/* recycle this frame */
+	if (dec)
+		dec->recycle(ctx, frame);
+}
+
+static int delta_vb2_frame_start_streaming(struct vb2_queue *q,
+					   unsigned int count)
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+
+	if (ctx->state == DELTA_STATE_STOPPED)
+		ctx->state = DELTA_STATE_READY;
+
+	return 0;
+}
+
+static void delta_vb2_frame_stop_streaming(struct vb2_queue *q)
+{
+	struct delta_ctx *ctx = to_ctx(q->drv_priv);
+	const struct delta_dec *dec = ctx->dec;
+	struct delta_frame *frame;
+	unsigned int i;
+
+	/* cancel ongoing decoding (if any, stuck at delta_wait_recycle) */
+	ctx->state = DELTA_STATE_STOPPED;
+	wake_up(&ctx->wq_recycle);
+
+	if (dec)
+		dec->flush(ctx);
+
+	/* force return of all pending
+	 * buffers to vb2 (in error state)
+	 */
+	for (i = 0; i < ctx->nb_of_frames; i++) {
+		frame = ctx->frames[i];
+		if (!(frame->state & DELTA_FRAME_OUT)) {
+			frame->state |= DELTA_FRAME_OUT;
+			vb2_buffer_done(&frame->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);
+		}
+	}
+}
+
+static struct vb2_ops delta_vb2_au_ops = {
+	.queue_setup = delta_vb2_au_queue_setup,
+	.buf_prepare = delta_vb2_au_prepare,
+	.buf_queue = delta_vb2_au_queue,
+	.wait_prepare = delta_vb2_unlock,
+	.wait_finish = delta_vb2_lock,
+	.stop_streaming = delta_vb2_au_stop_streaming,
+};
+
+static struct vb2_ops delta_vb2_frame_ops = {
+	.queue_setup = delta_vb2_frame_queue_setup,
+	.buf_prepare = delta_vb2_frame_prepare,
+	.buf_finish = delta_vb2_frame_finish,
+	.buf_queue = delta_vb2_frame_queue,
+	.wait_prepare = delta_vb2_unlock,
+	.wait_finish = delta_vb2_lock,
+	.start_streaming = delta_vb2_frame_start_streaming,
+	.stop_streaming = delta_vb2_frame_stop_streaming,
+};
+
+static int delta_open(struct file *file)
+{
+	struct delta_dev *delta = video_drvdata(file);
+	struct delta_ctx *ctx = NULL;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	mutex_lock(&delta->lock);
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	v4l2_fh_add(&ctx->fh);
+	ctx->dev = delta;
+
+	/* setup vb2 queue for stream input */
+	q = &ctx->q_aus;
+	q->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	q->drv_priv = &ctx->fh;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	/* overload vb2 buf with private au struct */
+	q->buf_struct_size = sizeof(struct delta_au);
+	q->ops = &delta_vb2_au_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(delta->dev, "[x:x] vb2_queue_init(aus) failed (%d)\n",
+			ret);
+		goto err_fh_del;
+	}
+
+	/* setup vb2 queue for frame output */
+	q = &ctx->q_frames;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->drv_priv = &ctx->fh;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	/* overload vb2 buf with private frame struct */
+	q->buf_struct_size = sizeof(struct delta_frame)
+			     + DELTA_MAX_FRAME_PRIV_SIZE;
+	q->ops = &delta_vb2_frame_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(delta->dev,
+			"[x:x] vb2_queue_init(frames) failed (%d)\n", ret);
+		goto err_fh_del;/* no cleanup needed for vb2_queue_init */
+	}
+
+	/* wait stream format to determine which
+	 * decoder to open, cf delta_s_fmt_stream.
+	 */
+	ctx->state = DELTA_STATE_WF_FORMAT;
+
+	INIT_LIST_HEAD(&ctx->list);
+	INIT_LIST_HEAD(&ctx->dts);
+	init_waitqueue_head(&ctx->wq_recycle);
+
+	/* name this instance */
+	delta->instance_id++;	/* rolling id to identify this instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:----]",
+		 delta->instance_id);
+
+	/* update delta device */
+	list_add_tail(&ctx->list, &delta->instances);
+	delta->nb_of_instances++;
+
+	/* enable ST231 clocks */
+	if (delta->clk_st231)
+		if (clk_prepare_enable(delta->clk_st231))
+			dev_warn(delta->dev, "failed to enable st231 clk\n");
+
+	/* enable FLASH_PROMIP clock */
+	if (delta->clk_flash_promip)
+		if (clk_prepare_enable(delta->clk_flash_promip))
+			dev_warn(delta->dev, "failed to enable delta promip clk\n");
+
+	mutex_unlock(&delta->lock);
+
+	return 0;
+
+err_fh_del:
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+	kfree(ctx);
+err:
+	mutex_unlock(&delta->lock);
+
+	return ret;
+}
+
+static int delta_release(struct file *file)
+{
+	struct delta_ctx *ctx = to_ctx(file->private_data);
+	struct delta_dev *delta = ctx->dev;
+	const struct delta_dec *dec = ctx->dec;
+	unsigned char str[200] = "";
+
+	mutex_lock(&delta->lock);
+
+	/* cancel ongoing decoding (if any, stuck at delta_wait_recycle) */
+	ctx->state = DELTA_STATE_CLOSED;
+	wake_up(&ctx->wq_recycle);
+
+	/* close decoder */
+	if (dec)
+		dec->close(ctx);
+
+	/* trace a summary of instance
+	 * before closing (debug purpose)
+	 */
+	if (ctx->flags & DELTA_FLAG_STREAMINFO)
+		dev_info(delta->dev, "%s %s\n", ctx->name,
+			 delta_summary_str(ctx, str, sizeof(str)));
+
+	/* update delta device */
+	delta->nb_of_instances--;
+	list_del(&ctx->list);
+
+	vb2_queue_release(&ctx->q_frames);	/* will free dma memory
+						 * of each frame in queue
+						 */
+	vb2_dma_contig_cleanup_ctx(ctx->q_frames.alloc_ctx[0]);
+
+	vb2_queue_release(&ctx->q_aus);	/* will free dma memory
+					 * of each aus in queue
+					 */
+
+	vb2_dma_contig_cleanup_ctx(ctx->q_aus.alloc_ctx[0]);
+
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+
+	/* disable ST231 clocks */
+	if (delta->clk_st231)
+		clk_disable_unprepare(delta->clk_st231);
+
+	/* disable FLASH_PROMIP clock */
+	if (delta->clk_flash_promip)
+		clk_disable_unprepare(delta->clk_flash_promip);
+
+	kfree(ctx);
+
+	mutex_unlock(&delta->lock);
+	return 0;
+}
+
+static int delta_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct delta_ctx *ctx = to_ctx(file->private_data);
+	struct delta_dev *delta = ctx->dev;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	enum v4l2_buf_type type;
+	int ret;
+
+	mutex_lock(&delta->lock);
+
+	/* offset used to differentiate OUTPUT/CAPTURE */
+	if (offset < MMAP_FRAME_OFFSET) {
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	} else {
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		vma->vm_pgoff -= (MMAP_FRAME_OFFSET >> PAGE_SHIFT);
+	}
+
+	/* vb2 call */
+	ret = vb2_mmap(to_vb2q(ctx, type), vma);
+	if (ret)
+		dev_err(delta->dev, "%s vb2_mmap failed (%d)\n",
+			ctx->name, ret);
+
+	mutex_unlock(&delta->lock);
+
+	return ret;
+}
+
+/* v4l2 ops */
+static const struct v4l2_file_operations delta_fops = {
+	.owner = THIS_MODULE,/*TBC, check coda for remove of OWNER*/
+	.open = delta_open,
+	.release = delta_release,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = delta_mmap,
+};
+
+/* v4l2 ioctl ops */
+static const struct v4l2_ioctl_ops delta_ioctl_ops = {
+	.vidioc_querycap = delta_querycap,
+
+	/* V4L2 "CAPTURE" = decoder frame output */
+	.vidioc_enum_fmt_vid_cap = delta_enum_fmt_frame,
+	.vidioc_g_fmt_vid_cap = delta_g_fmt_frame,
+	.vidioc_try_fmt_vid_cap = delta_try_fmt_frame,
+	.vidioc_s_fmt_vid_cap = delta_s_fmt_frame,
+
+	/* V4L2 "OUTPUT" = decoder stream access units input */
+	.vidioc_enum_fmt_vid_out = delta_enum_fmt_stream,
+	.vidioc_g_fmt_vid_out = delta_g_fmt_stream,
+	.vidioc_try_fmt_vid_out = delta_try_fmt_stream,
+	.vidioc_s_fmt_vid_out = delta_s_fmt_stream,
+
+	/* on below ops, buf->type used to switch to au or frame back-end */
+	.vidioc_reqbufs = delta_reqbufs,
+	.vidioc_querybuf = delta_querybuf,
+	.vidioc_expbuf = delta_expbuf,
+	.vidioc_qbuf = delta_qbuf,
+	.vidioc_dqbuf = delta_dqbuf,
+	.vidioc_streamon = delta_streamon,
+	.vidioc_streamoff = delta_streamoff,
+	.vidioc_g_crop = delta_g_crop,
+	.vidioc_decoder_cmd = delta_decoder_cmd,
+	.vidioc_subscribe_event = delta_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static int delta_probe(struct platform_device *pdev)
+{
+	struct delta_dev *delta;
+	struct device *dev = &pdev->dev;
+	struct video_device *vdev;
+	int ret;
+
+	delta = devm_kzalloc(dev, sizeof(*delta), GFP_KERNEL);
+	if (!delta)
+		return -ENOMEM;
+
+	delta->dev = dev;
+	delta->pdev = pdev;
+	platform_set_drvdata(pdev, delta);
+
+	mutex_init(&delta->lock);
+	INIT_LIST_HEAD(&delta->instances);
+
+	/* get clock resources */
+	delta->clk_delta = devm_clk_get(dev, "delta");
+	if (IS_ERR(delta->clk_delta)) {
+		dev_dbg(dev, "%s can't get delta clock\n", __func__);
+		delta->clk_delta = NULL;
+	}
+
+	delta->clk_st231 = devm_clk_get(dev, "delta-st231");
+	if (IS_ERR(delta->clk_st231)) {
+		dev_dbg(dev, "%s can't get delta-tx clock\n", __func__);
+		delta->clk_st231 = NULL;
+	}
+
+	delta->clk_flash_promip = devm_clk_get(dev, "delta-flash-promip");
+	if (IS_ERR(delta->clk_flash_promip)) {
+		dev_dbg(dev, "%s can't get delta-flash-promip clock\n",
+			__func__);
+		delta->clk_flash_promip = NULL;
+	}
+
+	/* init pm_runtime used for power management */
+	pm_runtime_set_autosuspend_delay(dev, DELTA_HW_AUTOSUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_enable(dev);
+
+	/* init firmware ipc channel */
+	delta_ipc_init(delta);
+
+	/* register all available decoders */
+	register_all(delta);
+
+	/* register on V4L2 */
+	ret = v4l2_device_register(dev, &delta->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "could not register v4l2 device\n");
+		return ret;
+	}
+
+	vdev = video_device_alloc();
+	vdev->fops = &delta_fops;
+	vdev->ioctl_ops = &delta_ioctl_ops;
+	vdev->release = video_device_release;
+	vdev->lock = &delta->lock;
+	vdev->v4l2_dev = &delta->v4l2_dev;
+	snprintf(vdev->name, sizeof(vdev->name), "%s", DELTA_NAME);
+	vdev->vfl_dir = VFL_DIR_M2M;
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, 0);
+	if (ret) {
+		dev_err(dev, "failed to register video device\n");
+		video_device_release(vdev);
+		return ret;
+	}
+	delta->vdev = vdev;
+	video_set_drvdata(vdev, delta);
+
+	dev_info(dev, "registered as /dev/video%d\n", vdev->num);
+
+	return 0;
+}
+
+static int delta_remove(struct platform_device *pdev)
+{
+	struct delta_dev *delta = platform_get_drvdata(pdev);
+
+	dev_info(delta->dev, "removing %s\n", pdev->name);
+
+	delta_ipc_exit(delta);
+
+	video_unregister_device(delta->vdev);
+	v4l2_device_unregister(&delta->v4l2_dev);
+
+	pm_runtime_put_autosuspend(delta->dev);
+	pm_runtime_disable(delta->dev);
+
+	return 0;
+}
+
+static int delta_runtime_suspend(struct device *dev)
+{
+	struct delta_dev *delta = dev_get_drvdata(dev);
+
+	if (delta->clk_delta)
+		clk_disable_unprepare(delta->clk_delta);
+
+	return 0;
+}
+
+static int delta_runtime_resume(struct device *dev)
+{
+	struct delta_dev *delta = dev_get_drvdata(dev);
+
+	if (delta->clk_delta)
+		if (clk_prepare_enable(delta->clk_delta))
+			dev_warn(dev, "failed to prepare/enable delta clk\n");
+
+	return 0;
+}
+
+static const struct dev_pm_ops delta_pm_ops = {
+	.runtime_suspend = delta_runtime_suspend,
+	.runtime_resume = delta_runtime_resume,
+};
+
+static const struct of_device_id delta_match_types[] = {
+	{
+	 .compatible = "st,delta",
+	 }, {
+	     /* end node */
+	     }
+};
+
+MODULE_DEVICE_TABLE(of, delta_match_types);
+
+struct platform_driver delta_driver = {
+	.probe = delta_probe,
+	.remove = delta_remove,
+	.driver = {
+		   .name = DELTA_NAME,
+		   .of_match_table = delta_match_types,
+		   .pm = &delta_pm_ops},
+};
+
+module_platform_driver(delta_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics DELTA video decoder V4L2 driver");
diff --git a/drivers/media/platform/sti/delta/delta.h b/drivers/media/platform/sti/delta/delta.h
new file mode 100644
index 0000000..ef54bff
--- /dev/null
+++ b/drivers/media/platform/sti/delta/delta.h
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Author: Hugues Fruchet <hugues.fruchet@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef DELTA_H
+#define DELTA_H
+
+#include <linux/rpmsg.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "delta-cfg.h"
+
+/*
+ * enum delta_state - state of decoding instance
+ *
+ *@DELTA_STATE_WF_FORMAT:
+ *	Wait for compressed format to be set by V4L2 client in order
+ *	to know what is the relevant decoder to open.
+ *
+ *@DELTA_STATE_WF_STREAMINFO:
+ *	Wait for stream information to be available (bitstream
+ *	header parsing is done).
+ *
+ *@DELTA_STATE_READY:
+ *	Decoding instance is ready to decode compressed access unit.
+ *
+ *@DELTA_STATE_CLOSING:
+ *	Decoding instance is closing.
+ */
+enum delta_state {
+	DELTA_STATE_WF_FORMAT,
+	DELTA_STATE_WF_STREAMINFO,
+	DELTA_STATE_READY,
+	DELTA_STATE_CLOSED,
+	DELTA_STATE_STOPPED,
+	DELTA_STATE_WF_EOS,
+	DELTA_STATE_EOS
+};
+
+/*
+ * struct delta_streaminfo - information read from stream (header)
+ *
+ * @flags:		validity of fields (crop, pixelaspect, coding, other)
+ * @width:		width of video stream
+ * @height:		height ""
+ * @streamformat:	fourcc compressed format of video (VP8, H264, ...)
+ * @dpb:		number of frames needed to decode a single frame
+ *                      (h264 dpb, up to 16)
+ * @crop:		cropping window inside output frame (1920x1080@0,0
+ *                      inside 1920x1088 frame for ex.)
+ * @pixelaspect:	pixel aspect ratio of video (4/3, 5/4)
+ * @field:		interlaced or not
+ * @frame_width:	width of output frame (encoder or decoder alignment
+ *                      constraint)
+ * @frame_height:	height of output frame (encoder or decoder alignment
+ *                      constraint)
+ * @profile:		profile string
+ * @level:		level string
+ * @other:		other string information from codec
+ */
+struct delta_streaminfo {
+	__u32 flags;
+	__u32 streamformat;
+	__u32 width;
+	__u32 height;
+	__u32 dpb;
+	struct v4l2_rect crop;
+	struct v4l2_fract pixelaspect;
+	enum v4l2_field field;
+	__u32 frame_width;
+	__u32 frame_height;
+	__u8 profile[32];
+	__u8 level[32];
+	__u8 other[32];
+};
+
+#define DELTA_STREAMINFO_FLAG_CROP		0x0001
+#define DELTA_STREAMINFO_FLAG_PIXELASPECT	0x0002
+#define DELTA_STREAMINFO_FLAG_OTHER		0x0004
+#define DELTA_AU_FREE	0x00
+#define DELTA_AU_OUT	0x01
+
+/*
+ * struct delta_au - access unit structure.
+ *
+ * @vbuf:	vb2 struct, to be kept first and not to be wrote by driver.
+ *		Allows to get the delta_au fields by just casting a vb2_buffer
+ *		with delta_au struct. This is allowed through the use of
+ *		vb2 custom buffer mechanism, cf @buf_struct_size of
+ *		struct vb2_queue in include/media/videobuf2-core.h
+ * @prepared:	boolean, if set vaddr/paddr are resolved
+ * @vaddr:	virtual address (kernel can read/write)
+ * @paddr:	physical address (for hardware)
+ * @flags:	access unit type (V4L2_BUF_FLAG_KEYFRAME/PFRAME/BFRAME)
+ * @dts:	decoding timestamp of this access unit
+ * @state:	access unit state for lifecycle tracking
+ *		(DELTA_AU_FREE/OUT)
+ */
+struct delta_au {
+	struct vb2_v4l2_buffer vbuf;	/* keep first!! */
+
+	int prepared;
+	__u32 size;
+	void *vaddr;
+	dma_addr_t paddr;
+	__u32 flags;
+	u64 dts;
+	__u32 state;
+};
+
+#define DELTA_FRAME_FREE	0x00
+#define DELTA_FRAME_REF		0x01
+#define DELTA_FRAME_BSY		0x02
+#define DELTA_FRAME_DEC		0x04
+#define DELTA_FRAME_OUT		0x08
+#define DELTA_FRAME_RDY		0x10
+
+/*
+ * struct delta_frame - frame structure.
+ *
+ * @vb2:	vb2 struct, to be kept first and not to be wrote by driver.
+ *		Allows to get the delta_frame fields by just casting
+ *		vb2_buffer with delta_frame struct. This is allowed through
+ *		the use of vb2 custom buffer mechanism, cf @buf_struct_size
+ *		of struct vb2_queue in include/media/videobuf2-core.h
+ * @prepared:	boolean, if set pix/vaddr/paddr are resolved
+ * @index:	frame index, aligned on V4L2 wow
+ * @pix:	frame format (width, height, pixel format, stride, ...)
+ * @vaddr:	virtual address (kernel can read/write)
+ * @paddr:	physical address (for hardware)
+ * @flags:	frame type (V4L2_BUF_FLAG_KEYFRAME/PFRAME/BFRAME)
+ * @dts:	decoding timestamp of this frame
+ * @state:	frame state for frame lifecycle tracking
+ *		(DELTA_FRAME_FREE/DEC/OUT/REC/...)
+ */
+struct delta_frame {
+	struct vb2_v4l2_buffer vbuf;	/* keep first!! */
+
+	int prepared;
+	__u32 index;
+	struct v4l2_pix_format pix;
+	void *vaddr;
+	dma_addr_t paddr;
+	__u32 flags;
+	u64 dts;
+	__u32 state;
+};
+
+struct delta_dts {
+	struct list_head list;
+	u64 val;
+};
+
+struct delta_buf {
+	__u32 size;
+	void *vaddr;
+	dma_addr_t paddr;
+	const char *name;
+	struct dma_attrs attrs_struct;
+	struct dma_attrs *attrs;
+};
+
+struct delta_ipc_ctx {
+	int cb_err;
+	__u32 copro_hdl;
+	struct completion done;
+	struct delta_buf ipc_buf_struct;
+	struct delta_buf *ipc_buf;
+};
+
+struct delta_ipc_param {
+	__u32 size;
+	void *data;
+};
+
+struct delta_ctx;
+
+struct delta_dec {
+	struct list_head list;
+	const char *name;
+	__u32 streamformat;
+	__u32 pixelformat;
+	/*
+	 * decoder ops
+	 */
+	int (*open)(struct delta_ctx *ctx);
+	int (*close)(struct delta_ctx *ctx);
+
+	/*
+	 * setup_frame() - setup frame to be used by decoder
+	 * @ctx:	(in) instance
+	 * @frame:	(in) frame to use
+	 *  @frame.index	(in) identifier of frame
+	 *  @frame.vaddr	(in) virtual address (kernel can read/write)
+	 *  @frame.paddr	(in) physical address (for hardware)
+	 *
+	 * Frame is to be allocated by caller, then given
+	 * to decoder through this call.
+	 * Several frames must be given to decoder (dpb),
+	 * each frame is identified using its index.
+	 */
+	int (*setup_frame)(struct delta_ctx *ctx, struct delta_frame *frame);
+
+	/*
+	 * get_streaminfo() - get stream related infos
+	 * @ctx:	(in) instance
+	 * @streaminfo:	(out) width, height, dpb,...
+	 *
+	 * Precondition: stream header must have been successfully
+	 * parsed to have this call successful & @streaminfo valid.
+	 * Header parsing must be done using decode(), giving
+	 * explicitly header access unit or first access unit of bitstream.
+	 * If no valid header is found, get_streaminfo will return -ENODATA,
+	 * in this case the next bistream access unit must be decoded till
+	 * get_streaminfo becomes successful.
+	 */
+	int (*get_streaminfo)(struct delta_ctx *ctx,
+			      struct delta_streaminfo *streaminfo);
+
+	/*
+	 * decode() - decode a single access unit
+	 * @ctx:	(in) instance
+	 * @au:		(in/out) access unit
+	 *  @au.size	(in) size of au to decode
+	 *  @au.vaddr	(in) virtual address (kernel can read/write)
+	 *  @au.paddr	(in) physical address (for hardware)
+	 *  @au.flags	(out) au type (V4L2_BUF_FLAG_KEYFRAME/
+	 *			PFRAME/BFRAME)
+	 *
+	 * Decode the access unit given. Decode is synchronous;
+	 * access unit memory is no more needed after this call.
+	 * After this call, none, one or several frames could
+	 * have been decoded, which can be retrieved using
+	 * get_frame().
+	 */
+	int (*decode)(struct delta_ctx *ctx, struct delta_au *au);
+
+	/*
+	 * get_frame() - get the next decoded frame available
+	 * @ctx:	(in) instance
+	 * @frame:	(out) frame with decoded data:
+	 *  @frame.index	(out) identifier of frame
+	 *  @frame.vaddr	(out) virtual address (kernel can read/write)
+	 *  @frame.paddr	(out) physical address (for hardware)
+	 *  @frame.pix		(out) width/height/format/stride/...
+	 *  @frame.flags	(out) frame type (V4L2_BUF_FLAG_KEYFRAME/
+	 *			PFRAME/BFRAME)
+	 *
+	 * Get the next available decoded frame.
+	 * If no frame is available, -ENODATA is returned.
+	 * If a frame is available, frame structure is filled with
+	 * relevant data, frame.index identifying this exact frame.
+	 * When this frame is no more needed by upper layers,
+	 * recycle() must be called giving this frame identifier.
+	 */
+	int (*get_frame)(struct delta_ctx *ctx, struct delta_frame **frame);
+
+	/*
+	 * recycle() - recycle the given frame
+	 * @ctx:	(in) instance
+	 * @frame:	(in) frame to recycle:
+	 *  @frame.index	(in) identifier of frame
+	 *
+	 * recycle() is to be called by user when the decoded frame
+	 * is no more needed (composition/display done).
+	 * This frame will then be reused by decoder to proceed
+	 * with next frame decoding.
+	 * If not enough frames have been provided through setup_frame(),
+	 * or recycle() is not called fast enough, the decoder can run out
+	 * of available frames to proceed with decoding (starvation).
+	 * This case is guarded by wq_recycle wait queue which ensures that
+	 * decoder is called only if at least one frame is available.
+	 */
+	void (*recycle)(struct delta_ctx *ctx, struct delta_frame *frame);
+
+	/*
+	 * flush() - flush decoder
+	 * @ctx:	(in) instance
+	 *
+	 * Reset decoder context and discard all internal buffers.
+	 * This allows implementation of seek, which leads to discontinuity
+	 * of input bitstream that decoder must know to restart its internal
+	 * decoding logic.
+	 */
+	void (*flush)(struct delta_ctx *ctx);
+
+	/*
+	 * drain() - drain decoder
+	 * @ctx:	(in) instance
+	 *
+	 * Mark decoder pending frames (decoded but not yet output) as ready
+	 * so that they can be output to client at EOS (End Of Stream).
+	 * get_frame() is to be called in a loop right after drain() to
+	 * get all those pending frames.
+	*/
+	void (*drain)(struct delta_ctx *ctx);
+
+	/*
+	 * boolean pm (power mgt)
+	 *
+	 * if set, decoder will manage power on its own
+	 */
+	unsigned int pm;
+};
+
+struct delta_dev;
+
+#define STR_LENGTH 1400
+#define MEM_STR_LENGTH 400
+
+#define DELTA_FLAG_STREAMINFO 0x0001
+
+/*
+ * struct delta_ctx - instance structure.
+ *
+ * @flags:		validity of fields (streaminfo)
+ * @list:		anchor for list of opened instances maintained
+ *			in delta_dev.
+ * @fh:			keep track of V4L2 file handle
+ * @dev:		keep track of device context
+ * @dec:		selected decoder context for this instance
+ * @ipc_ctx:		context of ipc communication with firmware
+ * @state:		instance state
+ * @q_aus:		V4L2 vb2 queue for access units, allocated by driver
+ *			but managed by vb2 framework.
+ * @q_frames:		V4L2 vb2 queue for frames, allocated by driver
+ *			but managed by vb2 framework.
+ * @width:		width given by user through S_FMT(OUTPUT), this is
+ *			typically the width claimed by demuxer from container,
+ *			which can be different of bitstream width read when
+ *			parsing header.
+ * @height:		same for height.
+ * @streamformat:	format of stream given by user through S_FMT(OUTPUT)
+ * @max_au_size:	max size of an access unit
+ * @streaminfo:		structure of stream information read by parsing
+ *			header
+ * @nb_of_aus:		number of access units
+ * @aus:		array of access units to keep track of state
+ * @wq_recycle:		wait queue to block access unit decoding if
+ *			no more frames are available
+ * @recycled_frames:	count of recycled (available for decode) frames
+ * @nb_of_frames:	number of frames available for decoding
+ * @frames:		array of decoding frames to keep track of frame
+ *			state and manage frame recycling
+ * @decoded_frames:	nb of decoded frames from opening
+ * @output_frames:	nb of output frames from opening
+ * @dropped_frames:	nb of frames dropped (ie access unit not parsed
+ *			or frame decoded but not output)
+ * @stream_errors:	nb of stream errors (corrupted, not supported, ...)
+ * @decode_errors:	nb of decode errors (firmware error)
+ * @sys_errors:		nb of system errors (memory, ipc, ...)
+ * @dts:		FIFO of decoding timestamp.
+ *			output frames are timestamped with incoming access
+ *			unit timestamps using this fifo.
+ * @name:		string naming this instance (debug purpose)
+ * @priv:		private decoder context for this instance, allocated
+ *			by decoder @open time.
+ */
+struct delta_ctx {
+	__u32 flags;
+
+	struct list_head list;
+
+	struct v4l2_fh fh;
+
+	struct delta_dev *dev;
+	const struct delta_dec *dec;
+
+	struct delta_ipc_ctx ipc_ctx;
+
+	enum delta_state state;
+
+	/* vb2 queues */
+	struct vb2_queue q_aus;
+	struct vb2_queue q_frames;
+
+	/* user input */
+	__u32 width;
+	__u32 height;
+	__u32 streamformat;
+	size_t max_au_size;
+
+	/* stream */
+	struct delta_streaminfo streaminfo;
+
+	/* input access units */
+	__u32 nb_of_aus;
+	struct delta_au *aus[DELTA_MAX_AUS];
+
+	/* output frames */
+	wait_queue_head_t wq_recycle;
+	u32 recycled_frames;
+	__u32 nb_of_frames;
+	struct delta_frame *frames[DELTA_MAX_FRAMES];
+
+	/* frames stats */
+	u32 decoded_frames;
+	u32 output_frames;
+	u32 dropped_frames;
+
+	/* errors */
+	u32 stream_errors;
+	u32 decode_errors;
+	u32 sys_errors;
+
+	/* decoding timestamps */
+	struct list_head dts;
+
+	char name[100];
+
+	/* decoder specific */
+	void *priv;
+};
+
+#define DELTA_MAX_DECODERS 10
+
+/*
+ * struct delta_dev - device struct, 1 per probe (so single one for
+ * all platform life)
+ *
+ * @v4l2_dev:		v4l2 device
+ * @vdev:		v4l2 video device
+ * @pdev:		platform device
+ * @dev:		device
+ * @lock:		device lock, for crit section & V4L2 ops serialization.
+ * @clk_delta:		delta main clock
+ * @clk_st231:		st231 coprocessor main clock
+ * @clk_flash_promip:	flash promip clock
+ * @decoders:		list of registered decoders
+ * @nb_of_decoders:	nb of registered decoders
+ * @instances:		list of currently opened instances
+ * @nb_of_instances:	nb of current opened instances
+ * @instance_id:	rolling counter identifying an instance (debug purpose)
+ * @rpmsg_driver:	rpmsg ipc driver
+ * @rpmsg_channel:	rpmsg ipc channel
+ */
+struct delta_dev {
+	/* device */
+	struct v4l2_device v4l2_dev;
+	struct video_device *vdev;
+	struct platform_device *pdev;
+	struct device *dev;
+	struct mutex lock;
+
+	/* clocks */
+	struct clk *clk_delta;
+	struct clk *clk_st231;
+	struct clk *clk_flash_promip;
+
+	/* decoders */
+	const struct delta_dec *decoders[DELTA_MAX_DECODERS];
+	u32 nb_of_decoders;
+
+	/* decoding instances */
+	struct list_head instances;
+	u32 nb_of_instances;
+	u8 instance_id;
+
+	/* ipc */
+	struct rpmsg_driver rpmsg_driver;
+	struct rpmsg_channel *rpmsg_channel;
+};
+
+static inline char *frame_type_str(__u32 flags)
+{
+	if (flags & V4L2_BUF_FLAG_KEYFRAME)
+		return "I";
+	if (flags & V4L2_BUF_FLAG_PFRAME)
+		return "P";
+	if (flags & V4L2_BUF_FLAG_BFRAME)
+		return "B";
+	return "?";
+}
+
+static inline char *frame_state_str(__u32 state, char *str, unsigned int len)
+{
+	snprintf(str, len, "%s %s %s %s %s",
+		 (state & DELTA_FRAME_REF)  ? "ref" : "   ",
+		 (state & DELTA_FRAME_BSY)  ? "bsy" : "   ",
+		 (state & DELTA_FRAME_DEC)  ? "dec" : "   ",
+		 (state & DELTA_FRAME_OUT)  ? "out" : "   ",
+		 (state & DELTA_FRAME_RDY)  ? "rdy" : "   ");
+	return str;
+}
+
+int delta_setup_frame(struct delta_ctx *ctx,
+		      struct delta_frame *frame);
+int delta_get_free_frame(struct delta_ctx *ctx,
+			 struct delta_frame **pframe);
+void delta_recycle(struct delta_ctx *ctx,
+		   struct delta_frame *frame);
+int delta_get_sync(struct delta_ctx *ctx);
+void delta_put_autosuspend(struct delta_ctx *ctx);
+
+#endif /* DELTA_H */
diff --git a/drivers/media/platform/sti/hva/Makefile b/drivers/media/platform/sti/hva/Makefile
new file mode 100644
index 0000000..495894b
--- /dev/null
+++ b/drivers/media/platform/sti/hva/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIDEO_STI_HVA) := hva.o
+hva-y := hva-v4l2.o hva-hw.o hva-mem.o hva-h264.o
diff --git a/drivers/media/platform/sti/hva/hva-h264.c b/drivers/media/platform/sti/hva/hva-h264.c
new file mode 100644
index 0000000..b9a3d2d
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-h264.c
@@ -0,0 +1,1096 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "hva.h"
+#include "hva-hw.h"
+#include "hva-mem.h"
+
+#define MAX_SPS_PPS_SIZE 128
+
+#define BITSTREAM_OFFSET_MASK 0x7F
+
+/* video max size*/
+#define H264_MAX_SIZE_W 1920
+#define H264_MAX_SIZE_H 1920
+
+/* macroBlocs number (width & height) */
+#define MB_W(w) ((w + 0xF)  / 0x10)
+#define MB_H(h) ((h + 0xF)  / 0x10)
+
+/* formula to get temporal or spatial data size */
+#define DATA_SIZE(w, h) (MB_W(w) * MB_H(h) * 16)
+
+#define SEARCH_WINDOW_BUFFER_MAX_SIZE(w) ((4 * MB_W(w) + 42) * 256 * 3 / 2)
+#define CABAC_CONTEXT_BUFFER_MAX_SIZE(w) (MB_W(w) * 16)
+#define CTX_MB_BUFFER_MAX_SIZE(w) (MB_W(w) * 16 * 8)
+#define SLICE_HEADER_SIZE (4 * 16)
+#define BRC_DATA_SIZE (5 * 16)
+
+/* source buffer copy in YUV 420 MB-tiled format with size=16*256*3/2 */
+#define CURRENT_WINDOW_BUFFER_MAX_SIZE (16 * 256 * 3 / 2)
+
+/*
+ * 4 lines of pixels (in Luma, Chroma blue and Chroma red) of top MB
+ * for deblocking with size=4*16*MBx*2
+ */
+#define LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(w) (4 * 16 * MB_W(w) * 2)
+
+/* factor for bitrate and cpb buffer size max values if profile >= high */
+#define H264_FACTOR_HIGH 1200
+
+/* factor for bitrate and cpb buffer size max values if profile < high */
+#define H264_FACTOR_BASELINE 1000
+
+/* number of bytes for NALU_TYPE_FILLER_DATA header and footer */
+#define H264_FILLER_DATA_SIZE 6
+
+struct h264_profile {
+	enum v4l2_mpeg_video_h264_level level;
+	u32 max_mb_per_seconds;
+	u32 max_frame_size;
+	u32 max_bitrate;
+	u32 max_cpb_size;
+	u32 min_comp_ratio;
+};
+
+static const struct h264_profile h264_infos_list[] = {
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_0, 1485, 99, 64, 175, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1B, 1485, 99, 128, 350, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_1, 3000, 396, 192, 500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_2, 6000, 396, 384, 1000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_3, 11880, 396, 768, 2000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_0, 11880, 396, 2000, 2000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_1, 19800, 792, 4000, 4000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_2, 20250, 1620, 4000, 4000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_0, 40500, 1620, 10000, 10000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_1, 108000, 3600, 14000, 14000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_2, 216000, 5120, 20000, 20000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_0, 245760, 8192, 20000, 25000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_1, 245760, 8192, 50000, 62500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_2, 522240, 8704, 50000, 62500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_5_0, 589824, 22080, 135000, 135000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 983040, 36864, 240000, 240000, 2}
+};
+
+enum hva_brc_type {
+	BRC_TYPE_NONE = 0,
+	BRC_TYPE_CBR = 1,
+	BRC_TYPE_VBR = 2,
+	BRC_TYPE_VBR_LOW_DELAY = 3
+};
+
+enum hva_entropy_coding_mode {
+	CAVLC = 0,
+	CABAC = 1
+};
+
+enum hva_picture_coding_type {
+	PICTURE_CODING_TYPE_I = 0,
+	PICTURE_CODING_TYPE_P = 1,
+	PICTURE_CODING_TYPE_B = 2
+};
+
+enum hva_h264_sampling_mode {
+	SAMPLING_MODE_NV12 = 0,
+	SAMPLING_MODE_UYVY = 1,
+	SAMPLING_MODE_RGB3 = 3,
+	SAMPLING_MODE_XRGB4 = 4,
+	SAMPLING_MODE_NV21 = 8,
+	SAMPLING_MODE_VYUY = 9,
+	SAMPLING_MODE_BGR3 = 11,
+	SAMPLING_MODE_XBGR4 = 12,
+	SAMPLING_MODE_RGBX4 = 20,
+	SAMPLING_MODE_BGRX4 = 28
+};
+
+enum hva_h264_nalu_type {
+	NALU_TYPE_UNKNOWN = 0,
+	NALU_TYPE_SLICE = 1,
+	NALU_TYPE_SLICE_DPA = 2,
+	NALU_TYPE_SLICE_DPB = 3,
+	NALU_TYPE_SLICE_DPC = 4,
+	NALU_TYPE_SLICE_IDR = 5,
+	NALU_TYPE_SEI = 6,
+	NALU_TYPE_SPS = 7,
+	NALU_TYPE_PPS = 8,
+	NALU_TYPE_AU_DELIMITER = 9,
+	NALU_TYPE_SEQ_END = 10,
+	NALU_TYPE_STREAM_END = 11,
+	NALU_TYPE_FILLER_DATA = 12,
+	NALU_TYPE_SPS_EXT = 13,
+	NALU_TYPE_PREFIX_UNIT = 14,
+	NALU_TYPE_SUBSET_SPS = 15,
+	NALU_TYPE_SLICE_AUX = 19,
+	NALU_TYPE_SLICE_EXT = 20
+};
+
+enum hva_h264_sei_payload_type {
+	SEI_BUFFERING_PERIOD = 0,
+	SEI_PICTURE_TIMING = 1,
+	SEI_STEREO_VIDEO_INFO = 21,
+	SEI_FRAME_PACKING_ARRANGEMENT = 45
+};
+
+/**
+ * stereo Video Info struct
+ */
+struct hva_h264_stereo_video_sei {
+	u8 field_views_flag;
+	u8 top_field_is_left_view_flag;
+	u8 current_frame_is_left_view_flag;
+	u8 next_frame_is_second_view_flag;
+	u8 left_view_self_contained_flag;
+	u8 right_view_self_contained_flag;
+};
+
+/**
+ * @frame_width: width in pixels of the buffer containing the input frame
+ * @frame_height: height in pixels of the buffer containing the input frame
+ * @frame_num: the parameter to be written in the slice header
+ * @picture_coding_type: type I, P or B
+ * @pic_order_cnt_type: POC mode, as defined in H264 std : can be 0,1,2
+ * @first_picture_in_sequence: flag telling to encoder that this is the
+ *			       first picture in a video sequence.
+ *			       Used for VBR
+ * @slice_size_type: 0 = no constraint to close the slice
+ *		     1= a slice is closed as soon as the slice_mb_size limit
+ *			is reached
+ *		     2= a slice is closed as soon as the slice_byte_size limit
+ *			is reached
+ *		     3= a slice is closed as soon as either the slice_byte_size
+ *			limit or the slice_mb_size limit is reached
+ * @slice_mb_size: defines the slice size in number of macroblocks
+ *		   (used when slice_size_type=1 or slice_size_type=3)
+ * @ir_param_option: defines the number of macroblocks per frame to be
+ *		     refreshed by AIR algorithm OR the refresh period
+ *		     by CIR algorithm
+ * @intra_refresh_type: enables the adaptive intra refresh algorithm.
+ *			Disable=0 / Adaptative=1 and Cycle=2 as intra refresh
+ * @use_constrained_intra_flag: constrained_intra_pred_flag from PPS
+ * @transform_mode: controls the use of 4x4/8x8 transform mode
+ * @disable_deblocking_filter_idc:
+ *		     0: specifies that all luma and chroma block edges of
+ *			the slice are filtered.
+ *		     1: specifies that deblocking is disabled for all block
+ *			edges of the slice.
+ *		     2: specifies that all luma and chroma block edges of
+ *			the slice are filtered with exception of the block edges
+ *			that coincide with slice boundaries
+ * @slice_alpha_c0_offset_div2: to be written in slice header,
+ *				controls deblocking
+ * @slice_beta_offset_div2: to be written in slice header,
+ *			    controls deblocking
+ * @encoder_complexity: encoder complexity control (IME).
+ *		     0 = I_16x16, P_16x16, Full ME Complexity
+ *		     1 = I_16x16, I_NxN, P_16x16, Full ME Complexity
+ *		     2 = I_16x16, I_NXN, P_16x16, P_WxH, Full ME Complexity
+ *		     4 = I_16x16, P_16x16, Reduced ME Complexity
+ *		     5 = I_16x16, I_NxN, P_16x16, Reduced ME Complexity
+ *		     6 = I_16x16, I_NXN, P_16x16, P_WxH, Reduced ME Complexity
+ *  @chroma_qp_index_offset: coming from picture parameter set
+ *			     (PPS see [H.264 STD] 7.4.2.2)
+ *  @entropy_coding_mode: entropy coding mode.
+ *			  0 = CAVLC
+ *			  1 = CABAC
+ * @brc_type: selects the bit-rate control algorithm
+ *		     0 = constant Qp, (no BRC)
+ *		     1 = CBR
+ *		     2 = VBR
+ * @quant: Quantization param used in case of fix QP encoding (no BRC)
+ * @non_VCL_NALU_Size: size of non-VCL NALUs (SPS, PPS, filler),
+ *		       used by BRC
+ * @cpb_buffer_size: size of Coded Picture Buffer, used by BRC
+ * @bit_rate: target bitrate, for BRC
+ * @qp_min: min QP threshold
+ * @qp_max: max QP threshold
+ * @framerate_num: target framerate numerator , used by BRC
+ * @framerate_den: target framerate denomurator , used by BRC
+ * @delay: End-to-End Initial Delay
+ * @strict_HRD_compliancy: flag for HDR compliancy (1)
+ *			   May impact quality encoding
+ * @addr_source_buffer: address of input frame buffer for current frame
+ * @addr_fwd_Ref_Buffer: address of reference frame buffer
+ * @addr_rec_buffer: address of reconstructed frame buffer
+ * @addr_output_bitstream_start: output bitstream start address
+ * @addr_output_bitstream_end: output bitstream end address
+ * @addr_external_sw : address of external search window
+ * @addr_lctx : address of context picture buffer
+ * @addr_local_rec_buffer: address of local reconstructed buffer
+ * @addr_spatial_context: address of spatial context buffer
+ * @bitstream_offset: offset in bits between aligned bitstream start
+ *		      address and first bit to be written by HVA.
+ *		      Range value is [0..63]
+ * @sampling_mode: Input picture format .
+ *		     0: YUV420 semi_planar Interleaved
+ *		     1: YUV422 raster Interleaved
+ * @addr_param_out: address of output parameters structure
+ * @addr_scaling_matrix: address to the coefficient of
+ *			 the inverse scaling matrix
+ * @addr_scaling_matrix_dir: address to the coefficient of
+ *			     the direct scaling matrix
+ * @addr_cabac_context_buffer: address of cabac context buffer
+ * @GmvX: Input information about the horizontal global displacement of
+ *	  the encoded frame versus the previous one
+ * @GmvY: Input information about the vertical global displacement of
+ *	  the encoded frame versus the previous one
+ * @window_width: width in pixels of the window to be encoded inside
+ *		  the input frame
+ * @window_height: width in pixels of the window to be encoded inside
+ *		   the input frame
+ * @window_horizontal_offset: horizontal offset in pels for input window
+ *			      within input frame
+ * @window_vertical_offset: vertical offset in pels for input window
+ *			    within input frame
+ * @addr_roi: Map of QP offset for the Region of Interest algorithm and
+ *	      also used for Error map.
+ *	      Bit 0-6 used for qp offset (value -64 to 63).
+ *	      Bit 7 used to force intra
+ * @addr_slice_header: address to slice header
+ * @slice_header_size_in_bits: size in bits of the Slice header
+ * @slice_header_offset0: Slice header offset where to insert
+ *			  first_Mb_in_slice
+ * @slice_header_offset1: Slice header offset where to insert
+ *			  slice_qp_delta
+ * @slice_header_offset2: Slice header offset where to insert
+ *			  num_MBs_in_slice
+ * @slice_synchro_enable: enable "slice ready" interrupt after each slice
+ * @max_slice_number: Maximum number of slice in a frame
+ *		      (0 is strictly forbidden)
+ * @rgb2_yuv_y_coeff: Four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the Y component.
+ *		      Y = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @rgb2_yuv_u_coeff: four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the Y component.
+ *		      Y = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @rgb2_yuv_v_coeff: Four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the U (Cb) component.
+ *		      U = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @slice_byte_size: maximum slice size in bytes
+ *		     (used when slice_size_type=2 or slice_size_type=3)
+ * @max_air_intra_mb_nb: Maximum number of intra macroblock in a frame
+ *			 for the AIR algorithm
+ * @brc_no_skip: Disable skipping in the Bitrate Controller
+ * @addr_brc_in_out_parameter: address of static buffer for BRC parameters
+ */
+struct hva_h264_td {
+	u16 frame_width;
+	u16 frame_height;
+	u32 frame_num;
+	u16 picture_coding_type;
+	u16 reserved1;
+	u16 pic_order_cnt_type;
+	u16 first_picture_in_sequence;
+	u16 slice_size_type;
+	u16 reserved2;
+	u32 slice_mb_size;
+	u16 ir_param_option;
+	u16 intra_refresh_type;
+	u16 use_constrained_intra_flag;
+	u16 transform_mode;
+	u16 disable_deblocking_filter_idc;
+	s16 slice_alpha_c0_offset_div2;
+	s16 slice_beta_offset_div2;
+	u16 encoder_complexity;
+	s16 chroma_qp_index_offset;
+	u16 entropy_coding_mode;
+	u16 brc_type;
+	u16 quant;
+	u32 non_vcl_nalu_size;
+	u32 cpb_buffer_size;
+	u32 bit_rate;
+	u16 qp_min;
+	u16 qp_max;
+	u16 framerate_num;
+	u16 framerate_den;
+	u16 delay;
+	u16 strict_hrd_compliancy;
+	u32 addr_source_buffer;
+	u32 addr_fwd_ref_buffer;
+	u32 addr_rec_buffer;
+	u32 addr_output_bitstream_start;
+	u32 addr_output_bitstream_end;
+	u32 addr_external_sw;
+	u32 addr_lctx;
+	u32 addr_local_rec_buffer;
+	u32 addr_spatial_context;
+	u16 bitstream_offset;
+	u16 sampling_mode;
+	u32 addr_param_out;
+	u32 addr_scaling_matrix;
+	u32 addr_scaling_matrix_dir;
+	u32 addr_cabac_context_buffer;
+	u32 reserved3;
+	u32 reserved4;
+	s16 gmv_x;
+	s16 gmv_y;
+	u16 window_width;
+	u16 window_height;
+	u16 window_horizontal_offset;
+	u16 window_vertical_offset;
+	u32 addr_roi;
+	u32 addr_slice_header;
+	u16 slice_header_size_in_bits;
+	u16 slice_header_offset0;
+	u16 slice_header_offset1;
+	u16 slice_header_offset2;
+	u32 reserved5;
+	u32 reserved6;
+	u16 reserved7;
+	u16 reserved8;
+	u16 slice_synchro_enable;
+	u16 max_slice_number;
+	u32 rgb2_yuv_y_coeff;
+	u32 rgb2_yuv_u_coeff;
+	u32 rgb2_yuv_v_coeff;
+	u32 slice_byte_size;
+	u16 max_air_intra_mb_nb;
+	u16 brc_no_skip;
+	u32 addr_temporal_context;
+	u32 addr_brc_in_out_parameter;
+};
+
+/**
+ * @ slice_size: slice size
+ * @ slice_start_time: start time
+ * @ slice_stop_time: stop time
+ * @ slice_num: slice number
+ */
+struct hva_h264_slice_po {
+	u32 slice_size;
+	u32 slice_start_time;
+	u32 slice_end_time;
+	u32 slice_num;
+};
+
+/**
+ * @ bitstream_size: bitstream size
+ * @ dct_bitstream_size: dtc bitstream size
+ * @ stuffing_bits: number of stuffing bits inserted by the encoder
+ * @ removal_time: removal time of current frame (nb of ticks 1/framerate)
+ * @ hvc_start_time: hvc start time
+ * @ hvc_stop_time: hvc stop time
+ * @ slice_count: slice count
+ */
+struct hva_h264_po {
+	u32 bitstream_size;
+	u32 dct_bitstream_size;
+	u32 stuffing_bits;
+	u32 removal_time;
+	u32 hvc_start_time;
+	u32 hvc_stop_time;
+	u32 slice_count;
+	u32 reserved0;
+	struct hva_h264_slice_po slice_params[16];
+};
+
+struct hva_h264_task {
+	struct hva_h264_td td;
+	struct hva_h264_po po;
+};
+
+struct hva_h264_ctx {
+	struct hva_buffer *seq_info_buf;
+	struct hva_buffer *ref_frame;
+	struct hva_buffer *rec_frame;
+};
+
+static int hva_h264_fill_slice_header(struct hva_ctx *pctx,
+				      u8 *slice_header_addr,
+				      struct hva_controls *ctrls,
+				      int frame_num,
+				      u16 *header_size,
+				      u16 *header_offset0,
+				      u16 *header_offset1,
+				      u16 *header_offset2)
+{
+	/*
+	 * with this HVA hardware version, part of the slice header is computed
+	 * on host and part by hardware.
+	 * The part of host is precomputed and available through this array.
+	 */
+	struct device *dev = ctx_to_dev(pctx);
+	int  cabac = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC;
+	const unsigned char slice_header[] = { 0x00, 0x00, 0x00, 0x01,
+					       0x41, 0x34, 0x07, 0x00};
+	int idr_pic_id = frame_num % 2;
+	enum hva_picture_coding_type type;
+	u32 frame_order = frame_num % ctrls->gop_size;
+
+	if (!(frame_num % ctrls->gop_size))
+		type = PICTURE_CODING_TYPE_I;
+	else
+		type = PICTURE_CODING_TYPE_P;
+
+	memcpy(slice_header_addr, slice_header, sizeof(slice_header));
+
+	*header_size = 56;
+	*header_offset0 = 40;
+	*header_offset1 = 13;
+	*header_offset2 = 0;
+
+	if (type == PICTURE_CODING_TYPE_I) {
+		slice_header_addr[4] = 0x65;
+		slice_header_addr[5] = 0x11;
+
+		/* toggle the I frame */
+		if ((frame_num / ctrls->gop_size) % 2) {
+			*header_size += 4;
+			*header_offset1 += 4;
+			slice_header_addr[6] = 0x04;
+			slice_header_addr[7] = 0x70;
+
+		} else {
+			*header_size += 2;
+			*header_offset1 += 2;
+			slice_header_addr[6] = 0x09;
+			slice_header_addr[7] = 0xC0;
+		}
+	} else {
+		if (ctrls->entropy_mode == cabac) {
+			*header_size += 1;
+			*header_offset1 += 1;
+			slice_header_addr[7] = 0x80;
+		}
+		/*
+		 * update slice header with P frame order
+		 * frame order is limited to 16 (coded on 4bits only)
+		 */
+		slice_header_addr[5] += ((frame_order & 0x0C) >> 2);
+		slice_header_addr[6] += ((frame_order & 0x03) << 6);
+	}
+
+	dev_dbg(dev,
+		"%s   %s slice header order %d idrPicId %d header size %d\n",
+		pctx->name, __func__, frame_order, idr_pic_id, *header_size);
+	return 0;
+}
+
+static int hva_h264_fill_data_nal(struct hva_ctx *pctx,
+				  unsigned int stuffing_bytes, u8 *addr,
+				  unsigned int *size)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };
+	unsigned int size_stream;
+
+	dev_dbg(dev, "%s   %s stuffing bytes %d\n", pctx->name, __func__,
+		stuffing_bytes);
+
+	size_stream = pctx->streaminfo.width * pctx->streaminfo.height;
+	if ((*size + stuffing_bytes + H264_FILLER_DATA_SIZE) > size_stream) {
+		dev_dbg(dev, "%s   %s too many stuffing bytes %d\n",
+			pctx->name, __func__, stuffing_bytes);
+		return 0;
+	}
+
+	/* start code */
+	memcpy(addr + *size, start, sizeof(start));
+	*size += sizeof(start);
+
+	/* nal_unit_type */
+	addr[*size] = NALU_TYPE_FILLER_DATA;
+	*size += 1;
+
+	memset(addr + *size, 0xff, stuffing_bytes);
+	*size += stuffing_bytes;
+
+	addr[*size] = 0x80;
+	*size += 1;
+
+	return 0;
+}
+
+static int hva_h264_fill_sei_nal(struct hva_ctx *pctx,
+				 enum hva_h264_sei_payload_type type,
+				 u8 *addr, u32 *size)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };
+	struct hva_h264_stereo_video_sei info;
+	u8 offset = 7;
+	u8 msg = 0;
+
+	/* start code */
+	memcpy(addr + *size, start, sizeof(start));
+	*size += sizeof(start);
+
+	/* nal_unit_type */
+	addr[*size] = NALU_TYPE_SEI;
+	*size += 1;
+
+	/* payload type */
+	addr[*size] = type;
+	*size += 1;
+
+	switch (type) {
+	case SEI_STEREO_VIDEO_INFO:
+		memset(&info, 0, sizeof(info));
+
+		/* set to top/bottom frame packing arrangement */
+		info.field_views_flag = 1;
+		info.top_field_is_left_view_flag = 1;
+
+		/* payload size */
+		addr[*size] = 1;
+		*size += 1;
+
+		/* payload */
+		msg = info.field_views_flag << offset--;
+
+		if (info.field_views_flag) {
+			msg |= info.top_field_is_left_view_flag <<
+			       offset--;
+		} else {
+			msg |= info.current_frame_is_left_view_flag <<
+			       offset--;
+			msg |= info.next_frame_is_second_view_flag <<
+			       offset--;
+		}
+		msg |= info.left_view_self_contained_flag << offset--;
+		msg |= info.right_view_self_contained_flag << offset--;
+
+		addr[*size] = msg;
+		*size += 1;
+
+		addr[*size] = 0x80;
+		*size += 1;
+
+		return 0;
+	case SEI_BUFFERING_PERIOD:
+	case SEI_PICTURE_TIMING:
+	case SEI_FRAME_PACKING_ARRANGEMENT:
+	default:
+		dev_err(dev, " %s   sei nal type not supported %d\n",
+			pctx->name, type);
+		return -EINVAL;
+	}
+}
+
+static int hva_h264_prepare_task(struct hva_ctx *pctx,
+				 struct hva_buffer *task,
+				 struct hva_frame *frame,
+				 struct hva_stream *stream)
+{
+	struct hva_device *hva = ctx_to_hdev(pctx);
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_td *td = &video_task->td;
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_buffer *seq_info_buf = ctx->seq_info_buf;
+	struct hva_buffer *fwd_ref_frame = ctx->ref_frame;
+	struct hva_buffer *loc_rec_frame = ctx->rec_frame;
+	struct hva_controls *ctrls = &pctx->ctrls;
+	struct v4l2_fract *time_per_frame = &pctx->time_per_frame;
+	int cavlc =  V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC;
+	u32 frame_num = pctx->stream_num;
+	u32 addr_esram = hva->esram_addr;
+	enum v4l2_mpeg_video_h264_level level;
+	dma_addr_t paddr = 0;
+	u8 *slice_header_vaddr;
+	u32 frame_width = pctx->frameinfo.frame_width;
+	u32 frame_height = pctx->frameinfo.frame_height;
+	u32 max_cpb_buffer_size;
+	unsigned int payload = stream->payload;
+	u32 max_bitrate;
+
+	mutex_lock(&hva->protect_mutex);
+
+	/* check width and height parameters */
+	if ((frame_width > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H)) ||
+	    (frame_height > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H))) {
+		dev_err(dev,
+			"%s   width(%d) or height(%d) exceeds limits (%dx%d)\n",
+			pctx->name, frame_width, frame_height,
+			H264_MAX_SIZE_W, H264_MAX_SIZE_H);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	level = ctrls->level;
+
+	memset(td, 0, sizeof(struct hva_h264_td));
+
+	td->frame_width = frame_width;
+	td->frame_height = frame_height;
+
+	/* set frame alignement */
+	td->window_width =  ALIGN(pctx->frameinfo.width, 16);
+	td->window_height = ALIGN(pctx->frameinfo.height, 16);
+	td->window_horizontal_offset = 0;
+	td->window_vertical_offset = 0;
+
+	td->first_picture_in_sequence = (!frame_num) ? 1 : 0;
+
+	/* pic_order_cnt_type hard coded to '2' as only I & P frames */
+	td->pic_order_cnt_type = 2;
+
+	/* useConstrainedIntraFlag set to false for better coding efficiency */
+	td->use_constrained_intra_flag = false;
+	td->brc_type = (ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)
+			? BRC_TYPE_CBR : BRC_TYPE_VBR;
+
+	td->entropy_coding_mode = (ctrls->entropy_mode == cavlc) ? CAVLC :
+				  CABAC;
+
+	/* convert bitrate in bits per seconds */
+	td->bit_rate = ctrls->bitrate * 1000;
+
+	/* set framerate, framerate = 1 n/ time per frame */
+	if (time_per_frame->numerator >= 536) {
+		/*
+		 * due to a hardware bug, framerate denominator can't exceed
+		 * 536 (BRC overflow). Compute nearest framerate
+		 */
+		td->framerate_den = 1;
+		td->framerate_num = (time_per_frame->denominator +
+				    (time_per_frame->numerator >> 1) - 1) /
+				    time_per_frame->numerator;
+
+		/*
+		 * update bitrate to introduce a correction due to
+		 * the new framerate
+		 * new bitrate = (old bitrate * new framerate) / old framerate
+		 */
+		td->bit_rate /= time_per_frame->numerator;
+		td->bit_rate *= time_per_frame->denominator;
+		td->bit_rate /= td->framerate_num;
+	} else {
+		td->framerate_den = time_per_frame->numerator;
+		td->framerate_num = time_per_frame->denominator;
+	}
+
+	/* compute maximum bitrate depending on profile */
+	if (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)
+		max_bitrate = h264_infos_list[level].max_bitrate *
+			      H264_FACTOR_HIGH;
+	else
+		max_bitrate = h264_infos_list[level].max_bitrate *
+			      H264_FACTOR_BASELINE;
+
+	/* check if bitrate doesn't exceed max size */
+	if (td->bit_rate > max_bitrate) {
+		dev_warn(dev,
+			 "%s   bitrate (%d) larger than level and profile allow, clip to %d\n",
+			 pctx->name, td->bit_rate, max_bitrate);
+		td->bit_rate = max_bitrate;
+	}
+
+	/* convert cpb_buffer_size in bits */
+	td->cpb_buffer_size = ctrls->cpb_size * 1000;
+
+	/* compute maximum cpb buffer size depending on profile */
+	if (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)
+		max_cpb_buffer_size =
+		    h264_infos_list[level].max_cpb_size * H264_FACTOR_HIGH;
+	else
+		max_cpb_buffer_size =
+		    h264_infos_list[level].max_cpb_size * H264_FACTOR_BASELINE;
+
+	/* check if cpb buffer size doesn't exceed max size */
+	if (td->cpb_buffer_size > max_cpb_buffer_size) {
+		dev_warn(dev,
+			 "%s   cpb size larger than level %d allows, clip to %d\n",
+			pctx->name, td->cpb_buffer_size,
+			max_cpb_buffer_size);
+		td->cpb_buffer_size = max_cpb_buffer_size;
+	}
+
+	/* enable skipping in the Bitrate Controller */
+	td->brc_no_skip = 0;
+
+	/* initial delay */
+	if ((ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) &&
+	    td->bit_rate)
+		td->delay = 1000 * (td->cpb_buffer_size / td->bit_rate);
+	else
+		td->delay = 0;
+
+	switch (pctx->frameinfo.fmt.pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+		td->sampling_mode = SAMPLING_MODE_NV12;
+		break;
+	case V4L2_PIX_FMT_NV21:
+		td->sampling_mode = SAMPLING_MODE_NV21;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		td->sampling_mode = SAMPLING_MODE_UYVY;
+		break;
+	case V4L2_PIX_FMT_VYUY:
+		td->sampling_mode = SAMPLING_MODE_VYUY;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		td->sampling_mode = SAMPLING_MODE_RGB3;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		td->sampling_mode = SAMPLING_MODE_BGR3;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		td->sampling_mode = SAMPLING_MODE_RGBX4;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		td->sampling_mode = SAMPLING_MODE_BGRX4;
+		break;
+	case V4L2_PIX_FMT_XRGB32:
+		td->sampling_mode = SAMPLING_MODE_XRGB4;
+		break;
+	case V4L2_PIX_FMT_XBGR32:
+		td->sampling_mode = SAMPLING_MODE_XBGR4;
+		break;
+	default:
+		dev_err(dev, "%s   invalid source pixel format\n",
+			pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/*
+	 * fill matrix color converter (RGB to YUV)
+	 * Y = 0,299 R + 0,587 G + 0,114 B
+	 * Cb = -0,1687 R -0,3313 G + 0,5 B + 128
+	 * Cr = 0,5 R - 0,4187 G - 0,0813 B + 128
+	 */
+	td->rgb2_yuv_y_coeff = 0x12031008;
+	td->rgb2_yuv_u_coeff = 0x800EF7FB;
+	td->rgb2_yuv_v_coeff = 0x80FEF40E;
+
+	/* enable/disable transform mode */
+	td->transform_mode = ctrls->dct8x8;
+
+	/* encoder complexity fix to 2, ENCODE_I_16x16_I_NxN_P_16x16_P_WxH */
+	td->encoder_complexity = 2;
+
+	/* quant fix to 28, default VBR value */
+	td->quant = 28;
+
+	if (td->framerate_den == 0) {
+		dev_err(dev, "%s   invalid framerate\n", pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/* if automatic framerate, deactivate bitrate controller */
+	if (td->framerate_num == 0)
+		td->brc_type = 0;
+
+	/* compliancy fix to true */
+	td->strict_hrd_compliancy = 1;
+
+	/* set minimum & maximum quantizers */
+	td->qp_min = clamp_val(ctrls->qpmin, 0, 51);
+	td->qp_max = clamp_val(ctrls->qpmax, 0, 51);
+
+	td->addr_source_buffer = frame->paddr;
+	td->addr_fwd_ref_buffer = fwd_ref_frame->paddr;
+	td->addr_rec_buffer = loc_rec_frame->paddr;
+
+	td->addr_output_bitstream_end = (u32)stream->paddr +
+					vb2_plane_size(&stream->v4l2.vb2_buf,
+						       0);
+
+	td->addr_output_bitstream_start = (u32)stream->paddr;
+	td->bitstream_offset = (((u32)stream->paddr & 0xF) << 3) &
+			       BITSTREAM_OFFSET_MASK;
+
+	td->addr_param_out = (u32)task->paddr +
+			     offsetof(struct hva_h264_task, po);
+
+	/* swap spatial and temporal context */
+	if (frame_num % 2) {
+		paddr = seq_info_buf->paddr;
+		td->addr_spatial_context =  ALIGN(paddr, 0x100);
+		paddr = seq_info_buf->paddr + DATA_SIZE(frame_width,
+							frame_height);
+		td->addr_temporal_context = ALIGN(paddr, 0x100);
+	} else {
+		paddr = seq_info_buf->paddr;
+		td->addr_temporal_context = ALIGN(paddr, 0x100);
+		paddr = seq_info_buf->paddr + DATA_SIZE(frame_width,
+							frame_height);
+		td->addr_spatial_context =  ALIGN(paddr, 0x100);
+	}
+
+	paddr = seq_info_buf->paddr + 2 * DATA_SIZE(frame_width, frame_height);
+
+	td->addr_brc_in_out_parameter =  ALIGN(paddr, 0x100);
+
+	paddr = td->addr_brc_in_out_parameter + BRC_DATA_SIZE;
+	td->addr_slice_header =  ALIGN(paddr, 0x100);
+	td->addr_external_sw =  ALIGN(addr_esram, 0x100);
+
+	addr_esram += SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width);
+	td->addr_local_rec_buffer = ALIGN(addr_esram, 0x100);
+
+	addr_esram += LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width);
+	td->addr_lctx = ALIGN(addr_esram, 0x100);
+
+	addr_esram += CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height));
+	td->addr_cabac_context_buffer = ALIGN(addr_esram, 0x100);
+
+	if (!(frame_num % ctrls->gop_size)) {
+		td->picture_coding_type = PICTURE_CODING_TYPE_I;
+		stream->v4l2.flags |= V4L2_BUF_FLAG_KEYFRAME;
+	} else {
+		td->picture_coding_type = PICTURE_CODING_TYPE_P;
+		stream->v4l2.flags &= ~V4L2_BUF_FLAG_KEYFRAME;
+	}
+
+	/* fill the slice header part */
+	slice_header_vaddr = seq_info_buf->vaddr + (td->addr_slice_header -
+			     seq_info_buf->paddr);
+
+	hva_h264_fill_slice_header(pctx, slice_header_vaddr, ctrls, frame_num,
+				   &td->slice_header_size_in_bits,
+				   &td->slice_header_offset0,
+				   &td->slice_header_offset1,
+				   &td->slice_header_offset2);
+
+	td->chroma_qp_index_offset = 2;
+	td->slice_synchro_enable = 0;
+	td->max_slice_number = 1;
+
+	/*
+	 * check the sps/pps header size for key frame only
+	 * sps/pps header was previously fill by libv4l
+	 * during qbuf of stream buffer
+	 */
+	if ((stream->v4l2.flags == V4L2_BUF_FLAG_KEYFRAME) &&
+	    (payload > MAX_SPS_PPS_SIZE)) {
+		dev_err(dev, "%s   invalid sps/pps size %d\n", pctx->name,
+			payload);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	if (stream->v4l2.flags != V4L2_BUF_FLAG_KEYFRAME)
+		payload = 0;
+
+	/* add SEI nal (video stereo info) */
+	if (ctrls->sei_fp && hva_h264_fill_sei_nal(pctx, SEI_STEREO_VIDEO_INFO,
+						   (u8 *)stream->vaddr,
+						   &payload)) {
+		dev_err(dev, "%s   fail to get SEI nal\n", pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/* fill size of non-VCL NAL units (SPS, PPS, filler and SEI) */
+	td->non_vcl_nalu_size = payload * 8;
+
+	/* compute bitstream offset & new start address of bitstream */
+	td->addr_output_bitstream_start += ((payload >> 4) << 4);
+	td->bitstream_offset += (payload - ((payload >> 4) << 4)) * 8;
+
+	stream->payload = payload;
+
+	mutex_unlock(&hva->protect_mutex);
+	return 0;
+
+err:
+	mutex_unlock(&hva->protect_mutex);
+	return -EINVAL;
+}
+
+static unsigned int hva_h264_get_au_size(struct hva_buffer *task)
+{
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_po *po = &video_task->po;
+
+	return po->bitstream_size;
+}
+
+static u32 hva_h264_get_stuffing_bytes(struct hva_buffer *task)
+{
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_po *po = &video_task->po;
+
+	return po->stuffing_bits >> 3;
+}
+
+/*
+ *              codec ioctls operations
+ */
+
+static int hva_h264_open(struct hva_ctx *pctx)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_h264_ctx *ctx = NULL;
+	struct hva_device *hva = ctx_to_hdev(pctx);
+	u32 frame_width = pctx->frameinfo.frame_width;
+	u32 frame_height = pctx->frameinfo.frame_height;
+	u32 size;
+	int ret = 0;
+
+	/* check esram size necessary to encode a frame */
+	size = SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width) +
+	       LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width) +
+	       CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height)) +
+	       CABAC_CONTEXT_BUFFER_MAX_SIZE(frame_width);
+
+	if (hva->esram_size < size) {
+		dev_err(dev, "%s   not enough esram (max:%d request:%d)\n",
+			pctx->name, hva->esram_size, size);
+		pctx->sys_errors++;
+		return -EINVAL;
+	}
+
+	/* allocate context for codec */
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		ret = -ENOMEM;
+
+	pctx->priv = (void *)ctx;
+
+	/* set info flags for debugfs */
+	pctx->streaminfo.flags |= HVA_STREAMINFO_FLAG_H264;
+
+	return ret;
+}
+
+static int hva_h264_close(struct hva_ctx *pctx)
+{
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct device *dev = ctx_to_dev(pctx);
+
+	if (ctx->seq_info_buf)
+		hva_mem_free(pctx, ctx->seq_info_buf);
+
+	if (ctx->rec_frame)
+		hva_mem_free(pctx, ctx->rec_frame);
+
+	if (ctx->ref_frame)
+		hva_mem_free(pctx, ctx->ref_frame);
+
+	if (pctx->task)
+		hva_mem_free(pctx, pctx->task);
+
+	devm_kfree(dev, ctx);
+
+	return 0;
+}
+
+static int hva_h264_encode(struct hva_ctx *pctx, struct hva_frame *frame,
+			   struct hva_stream *au)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct hva_buffer *tmp_frame;
+	struct hva_buffer *task;
+	u32 width = pctx->frameinfo.frame_width;
+	u32 height = pctx->frameinfo.frame_height;
+	u32 stuffing_bytes = 0;
+	int ret = 0;
+
+	/* allocate sequence info buffer & local frames if needed */
+	if (!ctx->seq_info_buf) {
+		ret = hva_mem_alloc(pctx,
+				    2 * DATA_SIZE(width, height) +
+				    SLICE_HEADER_SIZE +
+				    BRC_DATA_SIZE,
+				    "hva sequence info buffer",
+				    &ctx->seq_info_buf);
+		if (ret || !ctx->seq_info_buf) {
+			dev_err(dev,
+				"%s   no more memory for sequence info buffer\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	if (!ctx->ref_frame) {
+		ret = hva_mem_alloc(pctx,
+				    width * height * 3 / 2,
+				    "hva reference frame", &ctx->ref_frame);
+		if (ret || !ctx->ref_frame) {
+			dev_err(dev, "%s   more memory for reference frame\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	if (!ctx->rec_frame) {
+		ret = hva_mem_alloc(pctx,
+				    width * height * 3 / 2,
+				    "hva reconstructed frame", &ctx->rec_frame);
+		if (ret || !ctx->rec_frame) {
+			dev_err(dev,
+				"%s   no more memory for reconstructed frame\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	/* allocate task descriptor if not already done */
+	if (!pctx->task) {
+		ret = hva_mem_alloc(pctx,
+				    sizeof(struct hva_h264_task),
+				    "hva task descriptor", &pctx->task);
+		if (ret || !pctx->task) {
+			dev_err(dev,
+				"%s   no more memory for task descriptor\n",
+				pctx->name);
+			return -ENOMEM;
+		}
+	}
+
+	/* only one task allocated & used */
+	task = pctx->task;
+
+	ret = hva_h264_prepare_task(pctx, task, frame, au);
+	if (ret)
+		goto err;
+
+	ret = hva_hw_execute_task(pctx, H264_ENC, task);
+	if (ret)
+		goto err;
+
+	pctx->stream_num++;
+	au->payload += hva_h264_get_au_size(task);
+
+	stuffing_bytes = hva_h264_get_stuffing_bytes(task);
+
+	if (stuffing_bytes)
+		hva_h264_fill_data_nal(pctx, stuffing_bytes,
+				       (u8 *)au->vaddr,
+				       &au->payload);
+
+	vb2_set_plane_payload(&au->v4l2.vb2_buf, 0, au->payload);
+
+	/* switch reference & reconstructed frame */
+	tmp_frame = ctx->ref_frame;
+	ctx->ref_frame = ctx->rec_frame;
+	ctx->rec_frame = tmp_frame;
+
+	return 0;
+err:
+	vb2_set_plane_payload(&au->v4l2.vb2_buf, 0, 0);
+	return ret;
+}
+
+const struct hva_encoder nv12h264enc = {
+	.name = "H264(NV12)",
+	.pixelformat = V4L2_PIX_FMT_NV12,
+	.streamformat = V4L2_PIX_FMT_H264,
+	.max_width = H264_MAX_SIZE_W,
+	.max_height = H264_MAX_SIZE_H,
+	.open = hva_h264_open,
+	.close = hva_h264_close,
+	.encode = hva_h264_encode,
+};
+
+const struct hva_encoder nv21h264enc = {
+	.name = "H264(NV21)",
+	.pixelformat = V4L2_PIX_FMT_NV21,
+	.streamformat = V4L2_PIX_FMT_H264,
+	.max_width = H264_MAX_SIZE_W,
+	.max_height = H264_MAX_SIZE_H,
+	.open = hva_h264_open,
+	.close = hva_h264_close,
+	.encode = hva_h264_encode,
+};
diff --git a/drivers/media/platform/sti/hva/hva-hw.c b/drivers/media/platform/sti/hva/hva-hw.c
new file mode 100644
index 0000000..44f2d2a
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-hw.c
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include "hva.h"
+#include "hva-hw.h"
+
+/* HVA register offsets */
+#define HVA_HIF_REG_RST                 0x0100U
+#define HVA_HIF_REG_RST_ACK             0x0104U
+#define HVA_HIF_REG_MIF_CFG             0x0108U
+#define HVA_HIF_REG_HEC_MIF_CFG         0x010CU
+#define HVA_HIF_REG_CFL                 0x0110U
+#define HVA_HIF_FIFO_CMD                0x0114U
+#define HVA_HIF_FIFO_STS                0x0118U
+#define HVA_HIF_REG_SFL                 0x011CU
+#define HVA_HIF_REG_IT_ACK              0x0120U
+#define HVA_HIF_REG_ERR_IT_ACK          0x0124U
+#define HVA_HIF_REG_LMI_ERR             0x0128U
+#define HVA_HIF_REG_EMI_ERR             0x012CU
+#define HVA_HIF_REG_HEC_MIF_ERR         0x0130U
+#define HVA_HIF_REG_HEC_STS             0x0134U
+#define HVA_HIF_REG_HVC_STS             0x0138U
+#define HVA_HIF_REG_HJE_STS             0x013CU
+#define HVA_HIF_REG_CNT                 0x0140U
+#define HVA_HIF_REG_HEC_CHKSYN_DIS      0x0144U
+#define HVA_HIF_REG_CLK_GATING          0x0148U
+#define HVA_HIF_REG_VERSION             0x014CU
+#define HVA_HIF_REG_BSM                 0x0150U
+
+/* define value for version id register (HVA_HIF_REG_VERSION) */
+#define VERSION_ID_MASK	0x0000FFFF
+
+/* define values for BSM register (HVA_HIF_REG_BSM) */
+#define BSM_CFG_VAL1	0x0003F000
+#define BSM_CFG_VAL2	0x003F0000
+
+/* define values for memory interface register (HVA_HIF_REG_MIF_CFG) */
+#define MIF_CFG_VAL1	0x04460446
+#define MIF_CFG_VAL2	0x04460806
+#define MIF_CFG_VAL3	0x00000000
+
+/* define value for HEC memory interface register (HVA_HIF_REG_MIF_CFG) */
+#define HEC_MIF_CFG_VAL	0x000000C4
+
+/*  Bits definition for clock gating register (HVA_HIF_REG_CLK_GATING) */
+#define CLK_GATING_HVC	BIT(0)
+#define CLK_GATING_HEC	BIT(1)
+#define CLK_GATING_HJE	BIT(2)
+
+/* fix hva clock rate */
+#define CLK_RATE		300000000
+
+/* fix delay for pmruntime */
+#define AUTOSUSPEND_DELAY_MS	3
+
+static irqreturn_t hva_hw_its_interrupt(int irq, void *data)
+{
+	struct hva_device *hva = data;
+
+	/* read status registers */
+	hva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);
+	hva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);
+
+	/* acknowledge interruption */
+	writel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hva_hw_its_irq_thread(int irq, void *arg)
+{
+	struct hva_device *hva = arg;
+	struct device *dev = hva_to_dev(hva);
+	u32 status = hva->sts_reg & 0xFF;
+	u8 client_id = (hva->sts_reg & 0xFF00) >> 8;
+	struct hva_ctx *ctx = NULL;
+
+	dev_dbg(dev, "%s     %s: status :0x%02x fifo level :0x%02x\n",
+		HVA_PREFIX, __func__, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);
+
+	/* check client ID */
+	if (client_id >= MAX_CONTEXT) {
+		dev_err(dev, "%s     %s: bad client identifier: %d\n",
+			ctx->name, __func__, client_id);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		goto out;
+	}
+
+	ctx = hva->contexts_list[client_id];
+
+	switch (status) {
+	case NO_ERROR:
+		dev_dbg(dev, "%s     %s: no error\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_SLICE_READY:
+		dev_dbg(dev, "%s     %s: h264 slice ready\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_FRAME_SKIPPED:
+		dev_dbg(dev, "%s     %s: h264 frame skipped\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_BITSTREAM_OVERSIZE:
+		dev_err(dev, "%s     %s:h264 bitstream oversize\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case H264_SLICE_LIMIT_SIZE:
+		dev_err(dev, "%s     %s: h264 slice limit size is reached\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case H264_MAX_SLICE_NUMBER:
+		dev_err(dev, "%s     %s: h264 max slice number is reached\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case TASK_LIST_FULL:
+		dev_err(dev, "%s     %s:task list full\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case UNKNOWN_COMMAND:
+		dev_err(dev, "%s     %s:command not known\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case WRONG_CODEC_OR_RESOLUTION:
+		dev_err(dev, "%s     %s:wrong codec or resolution\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	default:
+		dev_err(dev, "%s     %s:status not recognized\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	}
+out:
+	complete(&hva->interrupt);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t hva_hw_err_interrupt(int irq, void *data)
+{
+	struct hva_device *hva = data;
+
+	/* read status registers */
+	hva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);
+	hva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);
+
+	/* read error registers */
+	hva->lmi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_LMI_ERR);
+	hva->emi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_EMI_ERR);
+	hva->hec_mif_err_reg = readl_relaxed(hva->regs +
+					     HVA_HIF_REG_HEC_MIF_ERR);
+
+	/* acknowledge interruption */
+	writel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hva_hw_err_irq_thread(int irq, void *arg)
+{
+	struct hva_device *hva = arg;
+	struct device *dev = hva_to_dev(hva);
+	u8 client_id = 0;
+	struct hva_ctx *ctx;
+
+	dev_dbg(dev, "%s     status :0x%02x fifo level :0x%02x\n",
+		HVA_PREFIX, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);
+
+	/* check client ID */
+	client_id = (hva->sts_reg & 0xFF00) >> 8;
+	if (client_id >= MAX_CONTEXT) {
+		dev_err(dev, "%s     bad client identifier: %d\n", HVA_PREFIX,
+			client_id);
+		goto out;
+	}
+
+	ctx = hva->contexts_list[client_id];
+
+	if (hva->lmi_err_reg) {
+		dev_err(dev, "%s     local memory interface error :0x%08x\n",
+			ctx->name, hva->lmi_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+
+	if (hva->lmi_err_reg) {
+		dev_err(dev, "%s     external memory iterface error :0x%08x\n",
+			ctx->name, hva->emi_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+
+	if (hva->hec_mif_err_reg) {
+		dev_err(dev, "%s     hec memory interface error :0x%08x\n",
+			ctx->name, hva->hec_mif_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+out:
+	complete(&hva->interrupt);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned long int hva_hw_get_chipset_id(struct hva_device *hva)
+{
+	struct device *dev = hva_to_dev(hva);
+	unsigned long int id;
+
+	mutex_lock(&hva->protect_mutex);
+
+	if (pm_runtime_get_sync(dev) < 0) {
+		dev_err(dev, "%s     get pm_runtime failed\n", HVA_PREFIX);
+		mutex_unlock(&hva->protect_mutex);
+		return -EFAULT;
+	}
+
+	id = readl_relaxed(hva->regs + HVA_HIF_REG_VERSION) &
+			   VERSION_ID_MASK;
+
+	pm_runtime_put_autosuspend(dev);
+
+	mutex_unlock(&hva->protect_mutex);
+
+	switch (id) {
+	case HVA_VERSION_V400:
+		dev_info(dev, "%s     chipset identifier 0x%lx\n",
+			 HVA_PREFIX, id);
+		break;
+	default:
+		dev_err(dev, "%s     unknown chipset identifier 0x%lx\n",
+			HVA_PREFIX, id);
+		id = HVA_VERSION_UNKNOWN;
+		break;
+	}
+
+	return id;
+}
+
+int hva_hw_probe(struct platform_device *pdev, struct hva_device *hva)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *regs;
+	struct resource *esram;
+	int irq = 0;
+	int ret = 0;
+
+	WARN_ON(!hva);
+	hva->pdev = pdev;
+	hva->dev = dev;
+
+	/* get a memory region for mmio */
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hva->regs = devm_ioremap_resource(dev, regs);
+	if (IS_ERR_OR_NULL(hva->regs)) {
+		dev_err(dev, "%s     failed to get regs\n", HVA_PREFIX);
+		return PTR_ERR(hva->regs);
+	}
+
+	/* get a memory region for esram from device tree */
+	esram = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (IS_ERR_OR_NULL(esram)) {
+		dev_err(dev, "%s     failed to get esram region\n", HVA_PREFIX);
+		return PTR_ERR(esram);
+	}
+
+	hva->esram_addr = esram->start;
+	hva->esram_size = esram->end - esram->start + 1;
+
+	/* get clock resource */
+	hva->clk = devm_clk_get(dev, "clk_hva");
+	if (IS_ERR(hva->clk)) {
+		dev_err(dev, "%s     failed to get clock\n", HVA_PREFIX);
+		return PTR_ERR(hva->clk);
+	}
+
+	ret = clk_prepare(hva->clk);
+	if (ret < 0) {
+		dev_err(dev, "%s     failed to prepare clock\n", HVA_PREFIX);
+		hva->clk = ERR_PTR(-EINVAL);
+		return ret;
+	}
+
+	/* retrieve irq number from board resources */
+	hva->irq_its = platform_get_irq(pdev, 0);
+	if (!hva->irq_its) {
+		dev_err(dev, "%s     failed to get IRQ resource\n", HVA_PREFIX);
+		goto err_clk;
+	}
+
+	/* request irq */
+	ret = devm_request_threaded_irq(dev, hva->irq_its, hva_hw_its_interrupt,
+					hva_hw_its_irq_thread,
+					IRQF_ONESHOT,
+					"hva_its_irq", (void *)hva);
+	if (ret) {
+		dev_err(dev, "%s     failed to register its IRQ 0x%x\n",
+			HVA_PREFIX, irq);
+		goto err_clk;
+	}
+	disable_irq(hva->irq_its);
+
+	/* retrieve irq number from board resources */
+	hva->irq_err = platform_get_irq(pdev, 1);
+	if (!hva->irq_err) {
+		dev_err(dev, "%s     failed to get IRQ resource\n", HVA_PREFIX);
+		goto err_clk;
+	}
+
+	/* request irq */
+	ret = devm_request_threaded_irq(dev, hva->irq_err, hva_hw_err_interrupt,
+					hva_hw_err_irq_thread,
+					IRQF_ONESHOT,
+					"hva_err_irq", (void *)hva);
+	if (ret) {
+		dev_err(dev, "%s     failed to register err IRQ 0x%x\n",
+			HVA_PREFIX, irq);
+		goto err_clk;
+	}
+	disable_irq(hva->irq_err);
+
+	/* initialisation of the protection mutex */
+	mutex_init(&hva->protect_mutex);
+
+	/* initialisation of completion signal */
+	init_completion(&hva->interrupt);
+
+	/* init pm_runtime used for power management */
+	pm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_enable(dev);
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0) {
+		dev_err(dev, "%s     failed to set PM\n", HVA_PREFIX);
+		goto err_pm;
+	}
+
+	/* check hardware ID */
+	hva->chip_id = hva_hw_get_chipset_id(hva);
+
+	if (hva->chip_id == HVA_VERSION_UNKNOWN) {
+		ret = -EINVAL;
+		goto err_pm;
+	}
+
+	dev_info(dev, "%s     found hva device (id=%lx)\n", HVA_PREFIX,
+		 hva->chip_id);
+
+	return 0;
+err_pm:
+	pm_runtime_put(dev);
+err_clk:
+	if (hva->clk)
+		clk_unprepare(hva->clk);
+
+	return ret;
+}
+
+void hva_hw_remove(struct hva_device *hva)
+{
+	struct device *dev = hva_to_dev(hva);
+
+	/* disable interrupt */
+	disable_irq(hva->irq_its);
+	disable_irq(hva->irq_err);
+
+	pm_runtime_put_autosuspend(dev);
+	pm_runtime_disable(dev);
+}
+
+int hva_hw_runtime_suspend(struct device *dev)
+{
+	struct hva_device *hva = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(hva->clk);
+
+	return 0;
+}
+
+int hva_hw_runtime_resume(struct device *dev)
+{
+	struct hva_device *hva = dev_get_drvdata(dev);
+
+	if (clk_prepare_enable(hva->clk)) {
+		dev_err(hva->dev, "%s     failed to prepare hva clk\n",
+			HVA_PREFIX);
+		return -EINVAL;
+	}
+
+	if (clk_set_rate(hva->clk, CLK_RATE)) {
+		dev_err(dev, "%s     failed to set clock frequency\n",
+			HVA_PREFIX);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,
+			struct hva_buffer *task)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	struct device *dev = hva_to_dev(hva);
+	u8 client_id = ctx->client_id;
+	u32 reg = 0;
+
+	mutex_lock(&hva->protect_mutex);
+
+	/* enable irqs */
+	enable_irq(hva->irq_its);
+	enable_irq(hva->irq_err);
+
+	if (pm_runtime_get_sync(dev) < 0) {
+		dev_err(dev, "%s     get pm_runtime failed\n", ctx->name);
+		ctx->sys_errors++;
+		goto out;
+	}
+
+	reg = readl_relaxed(hva->regs + HVA_HIF_REG_CLK_GATING);
+	switch (cmd) {
+	case H264_ENC:
+	case VP8_ENC:
+		reg |= CLK_GATING_HVC;
+		break;
+	default:
+		dev_warn(dev, "%s     unknown command 0x%x\n", ctx->name, cmd);
+		goto out;
+	}
+	writel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);
+
+	dev_dbg(dev, "%s     %s: Write configuration registers\n", ctx->name,
+		__func__);
+
+	/* byte swap config */
+	writel_relaxed(BSM_CFG_VAL1,
+		       hva->regs + HVA_HIF_REG_BSM);
+
+	/*
+	 * define Max Opcode Size and Max Message Size
+	 * for LMI and EMI
+	 */
+	writel_relaxed(MIF_CFG_VAL3,
+		       hva->regs + HVA_HIF_REG_MIF_CFG);
+	writel_relaxed(HEC_MIF_CFG_VAL,
+		       hva->regs + HVA_HIF_REG_HEC_MIF_CFG);
+
+	/* command FIFO: task_id[31:16] client_id[15:8] command_type[7:0] */
+	dev_dbg(dev, "%s     %s: Send task ( cmd:%d, task_desc:%pad)\n",
+		ctx->name, __func__, cmd + (client_id << 8), &task->paddr);
+	writel_relaxed(cmd + (client_id << 8), hva->regs + HVA_HIF_FIFO_CMD);
+	writel_relaxed(task->paddr, hva->regs + HVA_HIF_FIFO_CMD);
+
+	if (!wait_for_completion_timeout(&hva->interrupt,
+					 msecs_to_jiffies(2000))) {
+		dev_err(dev, "%s     %s:Time out on completion\n", ctx->name,
+			__func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+out:
+	disable_irq(hva->irq_its);
+	disable_irq(hva->irq_err);
+
+	switch (cmd) {
+	case H264_ENC:
+	case VP8_ENC:
+		reg &= ~CLK_GATING_HVC;
+		writel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);
+
+		break;
+	default:
+		dev_warn(dev, "%s     unknown command 0x%x\n", ctx->name, cmd);
+	}
+
+	pm_runtime_put_autosuspend(dev);
+	mutex_unlock(&hva->protect_mutex);
+
+	if (ctx->hw_err)
+		return -EFAULT;
+
+	return 0;
+}
diff --git a/drivers/media/platform/sti/hva/hva-hw.h b/drivers/media/platform/sti/hva/hva-hw.h
new file mode 100644
index 0000000..a28f2a5
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-hw.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_HW_H
+#define HVA_HW_H
+
+/* HVA Versions */
+#define HVA_VERSION_UNKNOWN    0x000
+#define HVA_VERSION_V400       0x400
+
+/* HVA command types */
+enum hva_hw_cmd_type {
+	/* RESERVED = 0x00 */
+	/* RESERVED = 0x01 */
+	H264_ENC = 0x02,
+	/* RESERVED = 0x03 */
+	/* RESERVED = 0x04 */
+	/* RESERVED = 0x05 */
+	VP8_ENC = 0x06,
+	/* RESERVED = 0x07 */
+	REMOVE_CLIENT = 0x08,
+	FREEZE_CLIENT = 0x09,
+	START_CLIENT = 0x0A,
+	FREEZE_ALL = 0x0B,
+	START_ALL = 0x0C,
+	REMOVE_ALL = 0x0D
+};
+
+/**
+ * hw encode error values
+ * NO_ERROR: Success, Task OK
+ * H264_BITSTREAM_OVERSIZE: VECH264 Bitstream size > bitstream buffer
+ * H264_FRAME_SKIPPED: VECH264 Frame skipped (refers to CPB Buffer Size)
+ * H264_SLICE_LIMIT_SIZE: VECH264 MB > slice limit size
+ * H264_MAX_SLICE_NUMBER: VECH264 max slice number reached
+ * H264_SLICE_READY: VECH264 Slice ready
+ * TASK_LIST_FULL: HVA/FPC task list full
+		   (discard latest transform command)
+ * UNKNOWN_COMMAND: Transform command not known by HVA/FPC
+ * WRONG_CODEC_OR_RESOLUTION: Wrong Codec or Resolution Selection
+ * NO_INT_COMPLETION: Time-out on interrupt completion
+ * LMI_ERR: Local Memory Interface Error
+ * EMI_ERR: External Memory Interface Error
+ * HECMI_ERR: HEC Memory Interface Error
+ */
+enum hva_hw_error {
+	NO_ERROR = 0x0,
+	H264_BITSTREAM_OVERSIZE = 0x2,
+	H264_FRAME_SKIPPED = 0x4,
+	H264_SLICE_LIMIT_SIZE = 0x5,
+	H264_MAX_SLICE_NUMBER = 0x7,
+	H264_SLICE_READY = 0x8,
+	TASK_LIST_FULL = 0xF0,
+	UNKNOWN_COMMAND = 0xF1,
+	WRONG_CODEC_OR_RESOLUTION = 0xF4,
+	NO_INT_COMPLETION = 0x100,
+	LMI_ERR = 0x101,
+	EMI_ERR = 0x102,
+	HECMI_ERR = 0x103,
+};
+
+int hva_hw_probe(struct platform_device *pdev, struct hva_device *hva);
+void hva_hw_remove(struct hva_device *hva);
+int hva_hw_runtime_suspend(struct device *dev);
+int hva_hw_runtime_resume(struct device *dev);
+int hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,
+			struct hva_buffer *task);
+
+#endif /* HVA_HW_H */
diff --git a/drivers/media/platform/sti/hva/hva-mem.c b/drivers/media/platform/sti/hva/hva-mem.c
new file mode 100644
index 0000000..a191fb2
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-mem.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "hva.h"
+#include "hva-mem.h"
+
+int hva_mem_alloc(struct hva_ctx *ctx, u32 size, const char *name,
+		  struct hva_buffer **buf)
+{
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_buffer *b;
+	dma_addr_t paddr;
+	void *base;
+	DEFINE_DMA_ATTRS(attrs);
+
+	b = devm_kzalloc(dev, sizeof(*b), GFP_KERNEL);
+	if (!b) {
+		ctx->sys_errors++;
+		return -ENOMEM;
+	}
+
+	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
+	base = dma_alloc_attrs(dev, size, &paddr, GFP_KERNEL | GFP_DMA, &attrs);
+	if (!base) {
+		dev_err(dev, "%s %s : dma_alloc_attrs failed for %s (size=%d)\n",
+			ctx->name, __func__, name, size);
+		ctx->sys_errors++;
+		devm_kfree(dev, b);
+		return -ENOMEM;
+	}
+
+	b->size = size;
+	b->paddr = paddr;
+	b->vaddr = base;
+	b->attrs = attrs;
+	b->name = name;
+
+	dev_dbg(dev,
+		"%s allocate %d bytes of HW memory @(virt=%p, phy=%pad): %s\n",
+		ctx->name, size, b->vaddr, &b->paddr, b->name);
+
+	/* return  hva buffer to user */
+	*buf = b;
+
+	return 0;
+}
+
+void hva_mem_free(struct hva_ctx *ctx, struct hva_buffer *buf)
+{
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev,
+		"%s free %d bytes of HW memory @(virt=%p, phy=%pad): %s\n",
+		ctx->name, buf->size, buf->vaddr, &buf->paddr, buf->name);
+
+	dma_free_attrs(dev, buf->size, buf->vaddr, buf->paddr, &buf->attrs);
+
+	devm_kfree(dev, buf);
+}
diff --git a/drivers/media/platform/sti/hva/hva-mem.h b/drivers/media/platform/sti/hva/hva-mem.h
new file mode 100644
index 0000000..2a482e1
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-mem.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_MEM_H
+#define HVA_MEM_H
+
+int hva_mem_alloc(struct hva_ctx *ctx,
+		  __u32 size,
+		  const char *name,
+		  struct hva_buffer **buf);
+
+void hva_mem_free(struct hva_ctx *ctx,
+		  struct hva_buffer *buf);
+
+#endif /* HVA_MEM_H */
diff --git a/drivers/media/platform/sti/hva/hva-v4l2.c b/drivers/media/platform/sti/hva/hva-v4l2.c
new file mode 100644
index 0000000..b545e7d
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-v4l2.c
@@ -0,0 +1,1610 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "hva.h"
+#include "hva-hw.h"
+
+#define HVA_NAME "hva"
+
+/*
+ * 1 frame at least for user
+ * limit number of frames to 16
+ */
+#define MAX_FRAMES	16
+#define MIN_FRAMES	1
+
+#define MIN_STREAMS	1
+
+#define HVA_MIN_WIDTH	32
+#define HVA_MAX_WIDTH	1920
+#define HVA_MIN_HEIGHT	32
+#define HVA_MAX_HEIGHT	1920
+
+#define DFT_CFG_WIDTH		HVA_MIN_WIDTH
+#define	DFT_CFG_HEIGHT		HVA_MIN_HEIGHT
+#define DFT_CFG_FRAME_NUM	1
+#define DFT_CFG_FRAME_DEN	30
+
+static const struct hva_frameinfo frame_dflt_fmt = {
+	.fmt		= {
+				.pixelformat	= V4L2_PIX_FMT_NV12,
+				.nb_planes	= 2,
+				.bpp		= 12,
+				.bpp_plane0	= 8,
+				.w_align	= 2,
+				.h_align	= 2
+			  },
+	.width		= DFT_CFG_WIDTH,
+	.height		= DFT_CFG_HEIGHT,
+	.crop		= {0, 0, DFT_CFG_WIDTH, DFT_CFG_HEIGHT},
+	.frame_width	= DFT_CFG_WIDTH,
+	.frame_height	= DFT_CFG_HEIGHT
+};
+
+static const struct hva_streaminfo stream_dflt_fmt = {
+	.streamformat	= V4L2_PIX_FMT_H264,
+	.width		= DFT_CFG_WIDTH,
+	.height		= DFT_CFG_HEIGHT
+};
+
+/* list of stream formats supported by hva hardware */
+const u32 stream_fmt[] = {
+	V4L2_PIX_FMT_H264,
+};
+
+/* list of pixel formats supported by hva hardware */
+static const struct hva_frame_fmt frame_fmts[] = {
+	/* NV12. YUV420SP - 1 plane for Y + 1 plane for (CbCr) */
+	{
+		.pixelformat	= V4L2_PIX_FMT_NV12,
+		.nb_planes	= 2,
+		.bpp		= 12,
+		.bpp_plane0	= 8,
+		.w_align	= 2,
+		.h_align	= 2
+	},
+	/* NV21. YUV420SP - 1 plane for Y + 1 plane for (CrCb) */
+	{
+		.pixelformat	= V4L2_PIX_FMT_NV21,
+		.nb_planes	= 2,
+		.bpp		= 12,
+		.bpp_plane0	= 8,
+		.w_align	= 2,
+		.h_align	= 2
+	},
+};
+
+/* offset to differentiate OUTPUT/CAPTURE @mmap */
+#define MMAP_FRAME_OFFSET BIT(30)
+
+/* registry of available encoders */
+const struct hva_encoder *hva_encoders[] = {
+	&nv12h264enc,
+	&nv21h264enc,
+};
+
+static const struct hva_encoder *hva_find_stream_fmt(struct hva_ctx *ctx,
+						     u32 pixelformat)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	const struct hva_encoder *enc;
+	unsigned int i;
+
+	for (i = 0; i < hva->nb_of_encoders; i++) {
+		enc = hva->encoders[i];
+		if (enc->streamformat == pixelformat)
+			return enc;
+	}
+
+	return NULL;
+}
+
+static const struct hva_frame_fmt *hva_find_frame_fmt(u32 pixelformat)
+{
+	const struct hva_frame_fmt *fmt;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(frame_fmts); i++) {
+		fmt = &frame_fmts[i];
+		if (fmt->pixelformat == pixelformat)
+			return fmt;
+	}
+
+	return NULL;
+}
+
+static void register_encoder(struct hva_device *hva,
+			     const struct hva_encoder *enc)
+{
+	if (hva->nb_of_encoders >= HVA_MAX_ENCODERS) {
+		dev_warn(hva->dev,
+			 "%s can't register encoder: max nb (%d) is reached!)\n",
+			 enc->name, HVA_MAX_ENCODERS);
+		return;
+	}
+
+	/* those encoder ops are mandatory */
+	WARN_ON(!enc->open);
+	WARN_ON(!enc->close);
+	WARN_ON(!enc->encode);
+
+	hva->encoders[hva->nb_of_encoders] = enc;
+	hva->nb_of_encoders++;
+	dev_info(hva->dev, "%s encoder registered\n", enc->name);
+}
+
+static void register_all(struct hva_device *hva)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hva_encoders); i++)
+		register_encoder(hva, hva_encoders[i]);
+}
+
+static int hva_open_encoder(struct hva_ctx *ctx, u32 streamformat,
+			    u32 pixelformat, struct hva_encoder **penc)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_encoder *enc;
+	unsigned int i;
+	int ret;
+
+	/* find an encoder which can deal with these formats */
+	for (i = 0; i < hva->nb_of_encoders; i++) {
+		enc = (struct hva_encoder *)hva->encoders[i];
+		if ((enc->streamformat == streamformat) &&
+		    (enc->pixelformat == pixelformat))
+			break;	/* found */
+	}
+
+	if (i == hva->nb_of_encoders) {
+		dev_err(dev, "%s no encoder found matching %4.4s => %4.4s\n",
+			ctx->name, (char *)&pixelformat, (char *)&streamformat);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s one encoder matching %4.4s => %4.4s\n",
+		ctx->name, (char *)&pixelformat, (char *)&streamformat);
+
+	/* update name instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:%4.4s]",
+		 hva->instance_id, (char *)&streamformat);
+
+	/* open encoder instance */
+	ret = enc->open(ctx);
+	if (ret) {
+		dev_err(hva->dev, "%s enc->open failed (%d)\n",
+			ctx->name, ret);
+		return ret;
+	}
+
+	*penc = enc;
+
+	return ret;
+}
+
+/* v4l2 ioctl operations */
+
+static int hva_querycap(struct file *file, void *priv,
+			struct v4l2_capability *cap)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct hva_device *hva = ctx_to_hdev(ctx);
+
+	strlcpy(cap->driver, hva->pdev->name, sizeof(cap->driver));
+	strlcpy(cap->card, hva->pdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 HVA_NAME);
+
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int hva_enum_fmt_stream(struct file *file, void *priv,
+			       struct v4l2_fmtdesc *f)
+{
+	/* index don't have to exceed number of stream format supported */
+	if (f->index >= ARRAY_SIZE(stream_fmt))
+		return -EINVAL;
+
+	/* pixel format */
+	f->pixelformat = stream_fmt[f->index];
+
+	/* compressed */
+	f->flags = V4L2_FMT_FLAG_COMPRESSED;
+
+	return 0;
+}
+
+static int hva_enum_fmt_frame(struct file *file, void *priv,
+			      struct v4l2_fmtdesc *f)
+{
+	/* index don't have to exceed number of  format supported */
+	if (f->index >= ARRAY_SIZE(frame_fmts))
+		return -EINVAL;
+
+	/* pixel format */
+	f->pixelformat = frame_fmts[f->index].pixelformat;
+
+	return 0;
+}
+
+static int hva_g_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	f->fmt.pix.width = ctx->streaminfo.width;
+	f->fmt.pix.height = ctx->streaminfo.height;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.pixelformat = ctx->streaminfo.streamformat;
+	f->fmt.pix.bytesperline = 0;
+	f->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height;
+
+	dev_dbg(dev, "%s G_FMT (stream): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+	return 0;
+}
+
+static int hva_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_frame_fmt *fmt = &ctx->frameinfo.fmt;
+	int width = ctx->frameinfo.frame_width;
+	int height = ctx->frameinfo.frame_height;
+
+	f->fmt.pix.width = ctx->frameinfo.width;
+	f->fmt.pix.height = ctx->frameinfo.height;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.pixelformat = fmt->pixelformat;
+	f->fmt.pix.bytesperline = (width * fmt->bpp_plane0) / 8;
+	f->fmt.pix.sizeimage = (width * height * fmt->bpp) / 8;
+
+	dev_dbg(dev, "%s G_FMT (frame): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	return 0;
+}
+
+static int hva_try_fmt_stream(struct file *file, void *priv,
+			      struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_encoder *enc;
+	u32 width, height;
+
+	enc = hva_find_stream_fmt(ctx, pix->pixelformat);
+	if (!enc) {
+		dev_dbg(dev, "%s TRY_FMT (stream): unsupported format %.4s\n",
+			ctx->name, (char *)&pix->pixelformat);
+		return -EINVAL;
+	}
+
+	/*
+	 * if the frame resolution is already fixed, only allow the same stream
+	 * resolution
+	 */
+	width = pix->width;
+	height = pix->height;
+	if (ctx->flags & HVA_FLAG_FRAMEINFO) {
+		pix->width = ctx->frameinfo.width;
+		pix->height = ctx->frameinfo.height;
+		if ((pix->width != width) || (pix->height != height))
+			dev_dbg(dev,
+				"%s TRY_FMT (stream): same resolution as frame %dx%d -> %dx%d\n",
+				ctx->name, width, height,
+				pix->width, pix->height);
+	} else {
+		/* adjust width & height */
+		v4l_bound_align_image(&pix->width,
+				      HVA_MIN_WIDTH, enc->max_width,
+				      0,
+				      &pix->height,
+				      HVA_MIN_HEIGHT, enc->max_height,
+				      0,
+				      0);
+
+		if ((pix->width != width) || (pix->height != height))
+			dev_dbg(dev,
+				"%s TRY_FMT (stream): resolution updated %dx%d -> %dx%d\n",
+				ctx->name, width, height,
+				pix->width, pix->height);
+	}
+
+	pix->bytesperline = 0;
+	pix->sizeimage = pix->width * pix->height;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int hva_try_fmt_frame(struct file *file, void *priv,
+			     struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_frame_fmt *format;
+	u32 width, height;
+
+	format = hva_find_frame_fmt(pix->pixelformat);
+	if (!format) {
+		dev_dbg(dev, "%s TRY_FMT (frame): unsupported format %.4s\n",
+			ctx->name, (char *)&pix->pixelformat);
+		return -EINVAL;
+	}
+
+	/* adjust width & height */
+	width = pix->width;
+	height = pix->height;
+	v4l_bound_align_image(&pix->width,
+			      HVA_MIN_WIDTH, HVA_MAX_WIDTH,
+			      ffs(format->w_align) - 1,
+			      &pix->height,
+			      HVA_MIN_HEIGHT, HVA_MAX_HEIGHT,
+			      ffs(format->h_align) - 1,
+			      0);
+
+	if ((pix->width != width) || (pix->height != height))
+		dev_dbg(dev,
+			"%s TRY_FMT (frame): resolution updated %dx%d -> %dx%d\n",
+			ctx->name, width, height, pix->width, pix->height);
+
+	width = ALIGN(pix->width, 16);
+	height = ALIGN(pix->height, 16);
+	pix->bytesperline = (width * format->bpp_plane0) / 8;
+	pix->sizeimage = (width * height * format->bpp) / 8;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int hva_s_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret;
+
+	dev_dbg(dev, "%s S_FMT (stream): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	ret = hva_try_fmt_stream(file, fh, f);
+	if (ret) {
+		dev_err(dev,
+			"%s S_FMT (stream): unsupported format %.4s\n",
+			ctx->name, (char *)&f->fmt.pix.pixelformat);
+		return ret;
+	}
+
+	if (vb2_is_streaming(&ctx->q_stream)) {
+		dev_err(dev, "%s S_FMT (stream): queue busy\n", ctx->name);
+		return -EBUSY;
+	}
+
+	ctx->streaminfo.width = f->fmt.pix.width;
+	ctx->streaminfo.height = f->fmt.pix.height;
+	ctx->streaminfo.streamformat = f->fmt.pix.pixelformat;
+	ctx->streaminfo.dpb = 1;
+	ctx->flags |= HVA_FLAG_STREAMINFO;
+
+	return 0;
+}
+
+static int hva_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_frame_fmt *fmt;
+	int ret;
+
+	dev_dbg(dev, "%s S_FMT (frame): %dx%d fmt %.4s size %d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	ret = hva_try_fmt_frame(file, fh, f);
+	if (ret) {
+		dev_err(dev, "%s S_FMT (frame): unsupported format %.4s\n",
+			ctx->name, (char *)&f->fmt.pix.pixelformat);
+		return ret;
+	}
+
+	if (vb2_is_streaming(&ctx->q_frame)) {
+		dev_err(dev, "%s S_FMT (frame): queue busy\n", ctx->name);
+		return -EBUSY;
+	}
+
+	fmt = hva_find_frame_fmt(pix->pixelformat);
+	if (!fmt)
+		return -EINVAL;
+
+	memcpy(&ctx->frameinfo.fmt, fmt, sizeof(struct hva_frame_fmt));
+	ctx->frameinfo.frame_width = ALIGN(pix->width, 16);
+	ctx->frameinfo.frame_height = ALIGN(pix->height, 16);
+	ctx->frameinfo.width = pix->width;
+	ctx->frameinfo.height = pix->height;
+	ctx->frameinfo.crop.width = pix->width;
+	ctx->frameinfo.crop.height = pix->height;
+	ctx->frameinfo.crop.left = 0;
+	ctx->frameinfo.crop.top = 0;
+	ctx->flags |= HVA_FLAG_FRAMEINFO;
+
+	return 0;
+}
+
+static int hva_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hva_ctx *ctx = container_of(ctrl->handler, struct hva_ctx,
+					   ctrl_handler);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s S_CTRL: id = %d, val = %d\n", ctx->name,
+		ctrl->id, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		ctx->ctrls.bitrate_mode = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+		ctx->ctrls.gop_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		ctx->ctrls.bitrate = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_ASPECT:
+		ctx->ctrls.aspect = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
+		ctx->ctrls.profile = ctrl->val;
+		if (ctx->flags & HVA_FLAG_STREAMINFO)
+			snprintf(ctx->streaminfo.profile,
+				 sizeof(ctx->streaminfo.profile),
+				 "%s", profile_str(ctx->ctrls.profile));
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
+		ctx->ctrls.level = ctrl->val;
+		if (ctx->flags & HVA_FLAG_STREAMINFO)
+			snprintf(ctx->streaminfo.level,
+				 sizeof(ctx->streaminfo.level),
+				 "%s", level_str(ctx->ctrls.level));
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:
+		ctx->ctrls.entropy_mode = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:
+		ctx->ctrls.cpb_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:
+		ctx->ctrls.dct8x8 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_MIN_QP:
+		ctx->ctrls.qpmin = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_MAX_QP:
+		ctx->ctrls.qpmax = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:
+		ctx->ctrls.vui_sar = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:
+		ctx->ctrls.vui_sar_idc = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:
+		ctx->ctrls.sei_fp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:
+		ctx->ctrls.sei_fp_type = ctrl->val;
+		break;
+	default:
+		dev_dbg(dev, "%s S_CTRL: invalid control (id = %d)\n",
+			ctx->name, ctrl->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops hva_ctrl_ops = {
+	.s_ctrl = hva_s_ctrl,
+};
+
+static int hva_ctrls_setup(struct hva_ctx *ctx)
+{
+	struct device *dev = ctx_to_dev(ctx);
+	u64 mask;
+	enum v4l2_mpeg_video_h264_sei_fp_arrangement_type sei_fp_type =
+		V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM;
+
+	v4l2_ctrl_handler_init(&ctx->ctrl_handler, 15);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,
+			       0,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_GOP_SIZE,
+			  1, 60, 1, 16);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_BITRATE,
+			  1, 50000, 1, 20000);
+
+	mask = ~(1 << V4L2_MPEG_VIDEO_ASPECT_1x1);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_ASPECT,
+			       V4L2_MPEG_VIDEO_ASPECT_1x1,
+			       mask,
+			       V4L2_MPEG_VIDEO_ASPECT_1x1);
+
+	mask = ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH));
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_PROFILE,
+			       V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH,
+			       mask,
+			       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_LEVEL,
+			       V4L2_MPEG_VIDEO_H264_LEVEL_4_2,
+			       0,
+			       V4L2_MPEG_VIDEO_H264_LEVEL_4_0);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC,
+			       0,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,
+			  1, 62500, 1, 25000);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,
+			  0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MIN_QP,
+			  0, 51, 1, 5);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MAX_QP,
+			  0, 51, 1, 51);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE,
+			  0, 1, 1, 1);
+
+	mask = ~(1 << V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,
+			       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1,
+			       mask,
+			       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING,
+			  0, 1, 1, 0);
+
+	mask = ~(1 << sei_fp_type);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE,
+			       sei_fp_type,
+			       mask,
+			       sei_fp_type);
+
+	if (ctx->ctrl_handler.error) {
+		int err = ctx->ctrl_handler.error;
+
+		dev_dbg(dev, "%s controls setup failed (%d)\n", ctx->name,
+			err);
+		v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+		return err;
+	}
+
+	v4l2_ctrl_handler_setup(&ctx->ctrl_handler);
+	return 0;
+}
+
+static int hva_s_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	ctx->time_per_frame.numerator = sp->parm.capture.timeperframe.numerator;
+	ctx->time_per_frame.denominator =
+	    sp->parm.capture.timeperframe.denominator;
+
+	dev_dbg(dev, "%s set parameters %d/%d\n",
+		ctx->name, ctx->time_per_frame.numerator,
+		ctx->time_per_frame.denominator);
+
+	return 0;
+}
+
+static int hva_g_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	sp->parm.capture.timeperframe.numerator = ctx->time_per_frame.numerator;
+	sp->parm.capture.timeperframe.denominator =
+	    ctx->time_per_frame.denominator;
+
+	dev_dbg(dev, "%s get parameters %d/%d\n",
+		ctx->name, ctx->time_per_frame.numerator,
+		ctx->time_per_frame.denominator);
+
+	return 0;
+}
+
+static int hva_reqbufs(struct file *file, void *priv,
+		       struct v4l2_requestbuffers *reqbufs)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s REQBUFS %s\n", ctx->name, to_type_str(reqbufs->type));
+
+	return vb2_reqbufs(get_queue(ctx, reqbufs->type), reqbufs);
+}
+
+static int hva_create_bufs(struct file *file, void *priv,
+			   struct v4l2_create_buffers *create)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s CREATE_BUFS %s\n", ctx->name,
+		to_type_str(create->format.type));
+
+	return vb2_create_bufs(get_queue(ctx, create->format.type), create);
+}
+
+static int hva_querybuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s QUERYBUF %s[%d]\n", ctx->name,
+		to_type_str(b->type), b->index);
+
+	ret = vb2_querybuf(get_queue(ctx, b->type), b);
+	if (ret)
+		return ret;
+
+	/* add an offset to differentiate OUTPUT/CAPTURE @mmap time */
+	if ((b->memory == V4L2_MEMORY_MMAP) &&
+	    (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		b->m.offset += MMAP_FRAME_OFFSET;
+	}
+
+	return 0;
+}
+
+static int hva_expbuf(struct file *file, void *fh, struct v4l2_exportbuffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s EXPBUF %s\n", ctx->name, to_type_str(b->type));
+
+	return vb2_expbuf(get_queue(ctx, b->type), b);
+}
+
+static int hva_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct vb2_queue *q = get_queue(ctx, b->type);
+
+	/* copy bytesused field from v4l2 buffer to vb2 buffer */
+	if ((b->index < MAX_FRAMES) &&
+	    (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		struct hva_stream *s = (struct hva_stream *)q->bufs[b->index];
+
+		s->payload = b->bytesused;
+	}
+
+	return vb2_qbuf(q, b);
+}
+
+static int hva_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct vb2_queue *q = get_queue(ctx, b->type);
+
+	return vb2_dqbuf(q, b, file->f_flags & O_NONBLOCK);
+}
+
+static int hva_streamon(struct file *file, void *priv, enum v4l2_buf_type type)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+
+	return vb2_streamon(get_queue(ctx, type), type);
+}
+
+static int hva_streamoff(struct file *file, void *priv, enum v4l2_buf_type type)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+
+	return vb2_streamoff(get_queue(ctx, type), type);
+}
+
+static int is_rect_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)
+{
+	/* return 1 if a is enclosed in b, or 0 otherwise. */
+	if (a->left < b->left || a->top < b->top)
+		return 0;
+
+	if (a->left + a->width > b->left + b->width)
+		return 0;
+
+	if (a->top + a->height > b->top + b->height)
+		return 0;
+
+	return 1;
+}
+
+static int hva_g_selection(struct file *file, void *fh,
+			   struct v4l2_selection *s)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		dev_dbg(dev, "%s G_SELECTION: invalid type (%d)\n",
+			ctx->name, s->type);
+		return -EINVAL;
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		/* cropped frame */
+		s->r = ctx->frameinfo.crop;
+		break;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		/* complete frame */
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = ctx->frameinfo.width;
+		s->r.height = ctx->frameinfo.height;
+		break;
+	default:
+		dev_dbg(dev, "%s G_SELECTION: invalid target (%d)\n",
+			ctx->name, s->target);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int hva_s_selection(struct file *file, void *fh,
+			   struct v4l2_selection *s)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_rect *in, out;
+
+	if ((s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
+	    (s->target != V4L2_SEL_TGT_CROP)) {
+		dev_dbg(dev, "%s S_SELECTION: invalid type (%d)\n",
+			ctx->name, s->type);
+		return -EINVAL;
+	}
+
+	in = &s->r;
+	out = *in;
+
+	/* align and check origin */
+	out.left = ALIGN(in->left, ctx->frameinfo.fmt.w_align);
+	out.top = ALIGN(in->top, ctx->frameinfo.fmt.h_align);
+
+	if (((out.left + out.width) >  ctx->frameinfo.width) ||
+	    ((out.top + out.height) >  ctx->frameinfo.height)) {
+		dev_dbg(dev, "%s S_SELECTION: invalid crop %dx%d@(%d,%d)\n",
+			ctx->name, out.width, out.height,
+			out.left, out.top);
+		return -EINVAL;
+	}
+
+	/* checks adjust constraints flags */
+	if (s->flags & V4L2_SEL_FLAG_LE && !is_rect_enclosed(&out, in))
+		return -ERANGE;
+
+	if (s->flags & V4L2_SEL_FLAG_GE && !is_rect_enclosed(in, &out))
+		return -ERANGE;
+
+	if ((out.left != in->left) || (out.top != in->top) ||
+	    (out.width != in->width) || (out.height != in->height))
+		*in = out;
+
+	ctx->frameinfo.crop = s->r;
+
+	return 0;
+}
+
+/* vb2 ioctls operations */
+
+static int hva_vb2_frame_queue_setup(struct vb2_queue *q,
+				     unsigned int *num_buffers,
+				     unsigned int *num_planes,
+				     unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int width = ctx->frameinfo.frame_width;
+	int height = ctx->frameinfo.frame_height;
+	unsigned int size;
+
+	dev_dbg(dev, "%s frame queue setup: num_buffers %d\n", ctx->name,
+		*num_buffers);
+
+	/* setup nb of frame buffers needed =
+	 * user need (*num_buffer given, usually for grab pipeline) +
+	 * encoder internal need
+	 */
+	if (*num_buffers > MAX_FRAMES) {
+		dev_dbg(dev,
+			"%s frame queue setup: num_buffers too high (%d), cut to %d\n",
+			ctx->name, *num_buffers, MAX_FRAMES);
+		*num_buffers = MAX_FRAMES;
+	}
+
+	if (sizes[0])
+		dev_dbg(dev,
+			"%s frame queue setup: sizes[0] already set to %d\n",
+			ctx->name, sizes[0]);
+
+	if (!(ctx->flags & HVA_FLAG_FRAMEINFO)) {
+		dev_dbg(dev,
+			"%s frame queue setup: frame format not set, using default\n",
+			ctx->name);
+	}
+
+	alloc_ctxs[0] = ctx->hva_dev->alloc_ctx;
+	size = (width * height * ctx->frameinfo.fmt.bpp) / 8;
+
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	/* only one plane supported */
+	*num_planes = 1;
+	sizes[0] = size;
+
+	return 0;
+}
+
+static int hva_vb2_frame_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_frame *fm = (struct hva_frame *)vb;
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	if (vbuf->field == V4L2_FIELD_ANY)
+		vbuf->field = V4L2_FIELD_NONE;
+	if (vbuf->field != V4L2_FIELD_NONE) {
+		dev_dbg(dev, "%s frame[%d] prepare: %d field not supported\n",
+			ctx->name, vb->index, vbuf->field);
+		return -EINVAL;
+	}
+
+	if (!fm->prepared) {
+		/* get memory addresses */
+		fm->vaddr = vb2_plane_vaddr(&fm->v4l2.vb2_buf, 0);
+		fm->paddr =
+			vb2_dma_contig_plane_dma_addr(&fm->v4l2.vb2_buf, 0);
+		fm->prepared = true;
+
+		ctx->num_frames++;
+
+		dev_dbg(dev, "%s frame[%d] prepared; virt=%p, phy=%pad\n",
+			ctx->name, vb->index, fm->vaddr,
+			&fm->paddr);
+	}
+
+	return 0;
+}
+
+static void hva_vb2_frame_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	const struct hva_encoder *enc = ctx_to_enc(ctx);
+	struct hva_frame *fm = NULL;
+	struct hva_stream *sr = NULL;
+	int ret = 0;
+
+	fm = (struct hva_frame *)vb;
+	fm->v4l2.sequence = ctx->frame_num++;
+
+	if (!vb2_is_streaming(q)) {
+		vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	/* get a free stream buffer */
+	if (list_empty(&ctx->list_stream)) {
+		dev_err(dev, "%s no free buffer for stream!\n",	ctx->name);
+		ctx->sys_errors++;
+		goto err;
+	}
+	sr = list_first_entry(&ctx->list_stream, struct hva_stream, list);
+
+	if (!sr)
+		goto err;
+
+	list_del(&sr->list);
+
+	/* encode the frame & get stream unit */
+	ret = enc->encode(ctx, fm, sr);
+	if (ret)
+		goto err;
+
+	/* propagate frame timestamp */
+	sr->v4l2.vb2_buf.timestamp = fm->v4l2.vb2_buf.timestamp;
+	sr->v4l2.field = V4L2_FIELD_NONE;
+	sr->v4l2.sequence = ctx->stream_num - 1;
+
+	ctx->num_streams++;
+
+	vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_DONE);
+	vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_DONE);
+
+	return;
+err:
+	if (sr)
+		vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+
+	vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+}
+
+static int hva_vb2_frame_start_streaming(struct vb2_queue *q,
+					 unsigned int count)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s frame start streaming\n", ctx->name);
+
+	/* open encoder when both start_streaming have been called */
+	if (!vb2_start_streaming_called(&ctx->q_stream))
+		return 0;
+
+	if (!ctx->encoder)
+		ret = hva_open_encoder(ctx,
+				       ctx->streaminfo.streamformat,
+				       ctx->frameinfo.fmt.pixelformat,
+				       &ctx->encoder);
+
+	return ret;
+}
+
+static void hva_vb2_frame_stop_streaming(struct vb2_queue *q)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s frame stop streaming\n", ctx->name);
+
+	ctx->frame_num = 0;
+}
+
+static int hva_vb2_stream_queue_setup(struct vb2_queue *q,
+				      unsigned int *num_buffers,
+				      unsigned int *num_planes,
+				      unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int width = ctx->streaminfo.width;
+	int height = ctx->streaminfo.height;
+	unsigned int size;
+
+	dev_dbg(dev, "%s stream queue setup: num_buffers %d\n", ctx->name,
+		*num_buffers);
+
+	if (sizes[0])
+		dev_warn(dev,
+			 "%s stream queue setup: sizes[0] already set to %d\n",
+			 ctx->name, sizes[0]);
+
+	if (!(ctx->flags & HVA_FLAG_STREAMINFO)) {
+		dev_err(dev,
+			"%s stream queue setup: stream format not set, using default\n",
+			ctx->name);
+	}
+
+	alloc_ctxs[0] = ctx->hva_dev->alloc_ctx;
+	size = width * height;
+
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	/* only one plane supported */
+	*num_planes = 1;
+	sizes[0] = size;
+
+	return 0;
+}
+
+static int hva_vb2_stream_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_stream *sr = (struct hva_stream *)vb;
+
+	if (!sr->prepared) {
+		/* get memory addresses */
+		sr->vaddr = vb2_plane_vaddr(&sr->v4l2.vb2_buf, 0);
+		sr->paddr = vb2_dma_contig_plane_dma_addr(&sr->v4l2.vb2_buf, 0);
+		sr->prepared = true;
+
+		dev_dbg(dev, "%s stream[%d] prepared; virt=%p, phy=%pad\n",
+			ctx->name, vb->index, sr->vaddr, &sr->paddr);
+	}
+
+	return 0;
+}
+
+static void hva_vb2_stream_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct hva_stream *sr = (struct hva_stream *)vb;
+
+	/* check validity of video stream */
+	if (vb) {
+		/* enqueue to the stream list */
+		list_add(&sr->list, &ctx->list_stream);
+	}
+}
+
+static int hva_vb2_stream_start_streaming(struct vb2_queue *q,
+					  unsigned int count)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s stream start streaming\n", ctx->name);
+
+	/* open encoder when both start_streaming have been called */
+	if (!vb2_start_streaming_called(&ctx->q_frame))
+		return 0;
+
+	if (!ctx->encoder)
+		ret = hva_open_encoder(ctx,
+				       ctx->streaminfo.streamformat,
+				       ctx->frameinfo.fmt.pixelformat,
+				       &ctx->encoder);
+
+	return ret;
+}
+
+static void hva_vb2_stream_stop_streaming(struct vb2_queue *q)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_stream *sr, *node;
+
+	dev_dbg(dev, "%s stream stop streaming\n", ctx->name);
+
+	ctx->stream_num = 0;
+
+	/* release all active buffers */
+	list_for_each_entry_safe(sr, node, &ctx->list_stream, list) {
+		list_del_init(&sr->list);
+		vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+}
+
+static struct vb2_ops hva_vb2_frame_ops = {
+	.queue_setup		= hva_vb2_frame_queue_setup,
+	.buf_prepare		= hva_vb2_frame_prepare,
+	.buf_queue		= hva_vb2_frame_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= hva_vb2_frame_start_streaming,
+	.stop_streaming		= hva_vb2_frame_stop_streaming
+};
+
+static struct vb2_ops hva_vb2_stream_ops = {
+	.queue_setup		= hva_vb2_stream_queue_setup,
+	.buf_prepare		= hva_vb2_stream_prepare,
+	.buf_queue		= hva_vb2_stream_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= hva_vb2_stream_start_streaming,
+	.stop_streaming		= hva_vb2_stream_stop_streaming,
+};
+
+/* file basics operations */
+
+static int hva_open(struct file *file)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct vb2_queue *q;
+	struct device *dev;
+	struct hva_ctx *ctx;
+	int ret = 0;
+	unsigned int i;
+
+	WARN_ON(!hva);
+	dev = hva->dev;
+
+	mutex_lock(&hva->lock);
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		mutex_unlock(&hva->lock);
+		return -ENOMEM;
+	}
+	ctx->hva_dev = hva;
+
+	/* store the context address in the contexts list */
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (!hva->contexts_list[i]) {
+			hva->contexts_list[i] = ctx;
+			/* save client id in context */
+			ctx->client_id = i;
+			break;
+		}
+	}
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	v4l2_fh_add(&ctx->fh);
+
+	ret = hva_ctrls_setup(ctx);
+	if (ret) {
+		dev_err(dev, "%s [x:x] failed to setup controls\n",
+			HVA_PREFIX);
+		ctx->sys_errors++;
+		goto err_fh_del;
+	}
+	ctx->fh.ctrl_handler = &ctx->ctrl_handler;
+
+	/* setup vb2 queue for frame */
+	q = &ctx->q_frame;
+	q->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->min_buffers_needed = MIN_FRAMES;
+
+	/* save file handle to private data field of the queue */
+	q->drv_priv = &ctx->fh;
+
+	/* overload vb2 buffer size with private struct */
+	q->buf_struct_size = sizeof(struct hva_frame);
+
+	q->ops = &hva_vb2_frame_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->lock = &hva->lock;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s [x:x] vb2_queue_init(frame) failed (%d)\n",
+			HVA_PREFIX,  ret);
+		ctx->sys_errors++;
+		goto err_ctrls;
+	}
+
+	/* setup vb2 queue for stream */
+	q = &ctx->q_stream;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->min_buffers_needed = MIN_STREAMS;
+
+	/* save file handle to private data field of the queue */
+	q->drv_priv = &ctx->fh;
+
+	/* overload vb2 buffer size with private struct */
+	q->buf_struct_size = sizeof(struct hva_stream);
+
+	q->ops = &hva_vb2_stream_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->lock = &hva->lock;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s [x:x] vb2_queue_init(stream) failed (%d)\n",
+			HVA_PREFIX, ret);
+		ctx->sys_errors++;
+		goto err_queue_del_frame;
+	}
+
+	/* initialize the list of stream buffers */
+	INIT_LIST_HEAD(&ctx->list_stream);
+
+	/* name this instance */
+	hva->instance_id++;	/* rolling id to identify this instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:----]", hva->instance_id);
+
+	/* set by default time per frame */
+	ctx->time_per_frame.numerator = DFT_CFG_FRAME_NUM;
+	ctx->time_per_frame.denominator = DFT_CFG_FRAME_DEN;
+
+	/* default format */
+	ctx->streaminfo = stream_dflt_fmt;
+	ctx->frameinfo = frame_dflt_fmt;
+
+	hva->nb_of_instances++;
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+
+err_queue_del_frame:
+	vb2_queue_release(&ctx->q_frame);
+err_ctrls:
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+err_fh_del:
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+	hva->contexts_list[ctx->client_id] = NULL;
+	devm_kfree(dev, ctx);
+
+	mutex_unlock(&hva->lock);
+
+	return ret;
+}
+
+static int hva_release(struct file *file)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	const struct hva_encoder *enc = ctx_to_enc(ctx);
+
+	dev_dbg(dev, "%s release instance\n", ctx->name);
+
+	mutex_lock(&hva->lock);
+
+	/* free queues */
+	vb2_queue_release(&ctx->q_frame);
+	vb2_queue_release(&ctx->q_stream);
+
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+
+	/* clear context in contexts list */
+	if ((ctx->client_id >= MAX_CONTEXT) ||
+	    (hva->contexts_list[ctx->client_id] != ctx)) {
+		dev_err(dev, "%s can't clear context in contexts list!\n",
+			ctx->name);
+		ctx->sys_errors++;
+	}
+	hva->contexts_list[ctx->client_id] = NULL;
+
+	/* close encoder */
+	if (enc)
+		enc->close(ctx);
+
+	devm_kfree(dev, ctx);
+
+	hva->nb_of_instances--;
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+}
+
+static int hva_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	enum v4l2_buf_type type;
+	int ret;
+
+	mutex_lock(&hva->lock);
+
+	/* offset used to differentiate OUTPUT/CAPTURE */
+	if (offset < MMAP_FRAME_OFFSET) {
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	} else {
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		vma->vm_pgoff -= (MMAP_FRAME_OFFSET >> PAGE_SHIFT);
+	}
+
+	/* vb2 call */
+	ret = vb2_mmap(get_queue(ctx, type), vma);
+	if (ret) {
+		dev_err(dev, "%s vb2_mmap failed (%d)\n", ctx->name, ret);
+		ctx->sys_errors++;
+		mutex_unlock(&hva->lock);
+		return ret;
+	}
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+}
+
+static unsigned int hva_poll(struct file *file, poll_table *wait)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct video_device *vfd = video_devdata(file);
+	unsigned long req_events = poll_requested_events(wait);
+	struct vb2_queue *src_q, *dst_q;
+	struct vb2_buffer *src_vb = NULL, *dst_vb = NULL;
+	unsigned int rc = 0;
+	unsigned long flags;
+
+	mutex_lock(&hva->lock);
+
+	if (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {
+		struct v4l2_fh *fh = file->private_data;
+
+		if (v4l2_event_pending(fh))
+			rc = POLLPRI;
+		else if (req_events & POLLPRI)
+			poll_wait(file, &fh->wait, wait);
+		if (!(req_events &
+			(POLLOUT | POLLWRNORM | POLLIN | POLLRDNORM)))
+			goto end;
+	}
+
+	src_q = &ctx->q_frame;
+	dst_q = &ctx->q_stream;
+
+	/*
+	 * There has to be at least one buffer queued on each queued_list, which
+	 * means either in driver already or waiting for driver to claim it
+	 * and start processing.
+	 */
+	if ((!src_q->streaming || list_empty(&src_q->queued_list)) &&
+	    (!dst_q->streaming || list_empty(&dst_q->queued_list))) {
+		rc |= POLLERR;
+		goto end;
+	}
+
+	spin_lock_irqsave(&src_q->done_lock, flags);
+	if (list_empty(&src_q->done_list))
+		poll_wait(file, &src_q->done_wq, wait);
+	spin_unlock_irqrestore(&src_q->done_lock, flags);
+
+	spin_lock_irqsave(&dst_q->done_lock, flags);
+	if (list_empty(&dst_q->done_list)) {
+		/*
+		 * If the last buffer was dequeued from the capture queue,
+		 * return immediately. DQBUF will return -EPIPE.
+		 */
+		if (dst_q->last_buffer_dequeued) {
+			spin_unlock_irqrestore(&dst_q->done_lock, flags);
+			rc |= POLLIN | POLLRDNORM;
+			goto end;
+		}
+
+		poll_wait(file, &dst_q->done_wq, wait);
+	}
+	spin_unlock_irqrestore(&dst_q->done_lock, flags);
+
+	spin_lock_irqsave(&src_q->done_lock, flags);
+	if (!list_empty(&src_q->done_list))
+		src_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,
+					  done_entry);
+	if (src_vb && (src_vb->state == VB2_BUF_STATE_DONE ||
+		       src_vb->state == VB2_BUF_STATE_ERROR))
+		rc |= POLLOUT | POLLWRNORM;
+	spin_unlock_irqrestore(&src_q->done_lock, flags);
+
+	spin_lock_irqsave(&dst_q->done_lock, flags);
+	if (!list_empty(&dst_q->done_list))
+		dst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,
+					  done_entry);
+	if (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE ||
+		       dst_vb->state == VB2_BUF_STATE_ERROR))
+		rc |= POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&dst_q->done_lock, flags);
+
+end:
+	mutex_unlock(&hva->lock);
+	return rc;
+}
+
+/* v4l2 ops */
+static const struct v4l2_file_operations hva_fops = {
+	.owner			= THIS_MODULE,
+	.open			= hva_open,
+	.release		= hva_release,
+	.unlocked_ioctl		= video_ioctl2,
+	.mmap			= hva_mmap,
+	.poll			= hva_poll,
+};
+
+/* v4l2 ioctl ops */
+static const struct v4l2_ioctl_ops hva_ioctl_ops = {
+	.vidioc_querycap		= hva_querycap,
+	.vidioc_enum_fmt_vid_cap	= hva_enum_fmt_stream,
+	.vidioc_enum_fmt_vid_out	= hva_enum_fmt_frame,
+	.vidioc_g_fmt_vid_cap		= hva_g_fmt_stream,
+	.vidioc_g_fmt_vid_out		= hva_g_fmt_frame,
+	.vidioc_try_fmt_vid_cap		= hva_try_fmt_stream,
+	.vidioc_try_fmt_vid_out		= hva_try_fmt_frame,
+	.vidioc_s_fmt_vid_cap		= hva_s_fmt_stream,
+	.vidioc_s_fmt_vid_out		= hva_s_fmt_frame,
+	.vidioc_g_parm			= hva_g_parm,
+	.vidioc_s_parm			= hva_s_parm,
+	.vidioc_reqbufs			= hva_reqbufs,
+	.vidioc_create_bufs             = hva_create_bufs,
+	.vidioc_querybuf		= hva_querybuf,
+	.vidioc_expbuf			= hva_expbuf,
+	.vidioc_qbuf			= hva_qbuf,
+	.vidioc_dqbuf			= hva_dqbuf,
+	.vidioc_streamon		= hva_streamon,
+	.vidioc_streamoff		= hva_streamoff,
+	.vidioc_g_selection		= hva_g_selection,
+	.vidioc_s_selection		= hva_s_selection,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+};
+
+static int hva_probe(struct platform_device *pdev)
+{
+	struct hva_device *hva;
+	struct device *dev = &pdev->dev;
+	struct video_device *vdev;
+	int ret;
+
+	hva = devm_kzalloc(dev, sizeof(*hva), GFP_KERNEL);
+	if (!hva) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	hva->dev = dev;
+	hva->pdev = pdev;
+	platform_set_drvdata(pdev, hva);
+
+	mutex_init(&hva->lock);
+
+	/* probe hardware */
+	ret = hva_hw_probe(pdev, hva);
+	if (ret)
+		goto err;
+
+	/* register all available encoders */
+	register_all(hva);
+
+	/* register on V4L2 */
+	ret = v4l2_device_register(dev, &hva->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "%s %s could not register v4l2 device\n",
+			HVA_PREFIX, HVA_NAME);
+		goto err_hw_remove;
+	}
+
+	/* continuous memory allocator */
+	hva->alloc_ctx = vb2_dma_contig_init_ctx(dev);
+	if (IS_ERR(hva->alloc_ctx)) {
+		ret = PTR_ERR(hva->alloc_ctx);
+		goto err_v4l2;
+	}
+
+	vdev = video_device_alloc();
+	vdev->fops = &hva_fops;
+	vdev->ioctl_ops = &hva_ioctl_ops;
+	vdev->release = video_device_release;
+	vdev->lock = &hva->lock;
+	vdev->v4l2_dev = &hva->v4l2_dev;
+	snprintf(vdev->name, sizeof(vdev->name), "%s", HVA_NAME);
+	vdev->vfl_dir = VFL_DIR_M2M;
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret) {
+		dev_err(dev, "%s %s failed to register video device\n",
+			HVA_PREFIX, HVA_NAME);
+		goto err_vdev_release;
+	}
+
+	hva->vdev = vdev;
+	video_set_drvdata(vdev, hva);
+
+	dev_info(dev, "%s %s registered as /dev/video%d\n", HVA_PREFIX,
+		 HVA_NAME, vdev->num);
+
+	dev_info(dev, "%s %s esram reserved for address: 0x%x size:%d\n",
+		 HVA_PREFIX, HVA_NAME, hva->esram_addr,
+		 hva->esram_size);
+
+	return 0;
+
+err_vdev_release:
+	video_device_release(vdev);
+	vb2_dma_contig_cleanup_ctx(hva->alloc_ctx);
+err_v4l2:
+	v4l2_device_unregister(&hva->v4l2_dev);
+err_hw_remove:
+	hva_hw_remove(hva);
+err:
+	return ret;
+}
+
+static int hva_remove(struct platform_device *pdev)
+{
+	struct hva_device *hva = platform_get_drvdata(pdev);
+	struct device *dev = hva_to_dev(hva);
+
+	dev_info(dev, "%s removing %s\n", HVA_PREFIX, pdev->name);
+
+	hva_hw_remove(hva);
+
+	vb2_dma_contig_cleanup_ctx(hva->alloc_ctx);
+
+	video_unregister_device(hva->vdev);
+
+	v4l2_device_unregister(&hva->v4l2_dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops hva_pm_ops = {
+	.runtime_suspend	= hva_hw_runtime_suspend,
+	.runtime_resume		= hva_hw_runtime_resume,
+};
+
+static const struct of_device_id hva_match_types[] = {
+	{
+	 .compatible = "st,sti-hva",
+	},
+	{ /* end node */ }
+};
+
+MODULE_DEVICE_TABLE(of, hva_match_types);
+
+struct platform_driver hva_driver = {
+	.probe  = hva_probe,
+	.remove = hva_remove,
+	.driver = {
+		.name           = HVA_NAME,
+		.owner          = THIS_MODULE,
+		.of_match_table = hva_match_types,
+		.pm             = &hva_pm_ops,
+		},
+};
+
+module_platform_driver(hva_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
+MODULE_DESCRIPTION("HVA video encoder V4L2 driver");
diff --git a/drivers/media/platform/sti/hva/hva.h b/drivers/media/platform/sti/hva/hva.h
new file mode 100644
index 0000000..402a580
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva.h
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_H
+#define HVA_H
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-v4l2.h>
+
+#define get_queue(c, t) (t == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \
+			 &c->q_frame : &c->q_stream)
+
+#define to_type_str(type) (type == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \
+			   "frame" : "stream")
+
+#define fh_to_ctx(f)    (container_of(f, struct hva_ctx, fh))
+
+#define hva_to_dev(h)   (h->dev)
+
+#define ctx_to_dev(c)   (c->hva_dev->dev)
+
+#define ctx_to_hdev(c)  (c->hva_dev)
+
+#define ctx_to_enc(c)   (c->encoder)
+
+#define HVA_PREFIX "[---:----]"
+
+#define MAX_CONTEXT 16
+
+extern const struct hva_encoder nv12h264enc;
+extern const struct hva_encoder nv21h264enc;
+
+/**
+ * struct hva_frame_fmt - driver's internal color format data
+ *
+ * @pixelformat: fourcc code for uncompressed video format
+ * @nb_planes:   number of planes (e.g. [0]=RGB/Y - [1]=Cb/Cr - ...)
+ * @bpp:         bits per pixel (general)
+ * @bpp_plane0:  byte per pixel for the 1st plane
+ * @w_align:     width alignment in pixel (multiple of)
+ * @h_align:     height alignment in pixel (multiple of)
+ */
+struct hva_frame_fmt {
+	u32	pixelformat;
+	u8	nb_planes;
+	u8	bpp;
+	u8	bpp_plane0;
+	u8	w_align;
+	u8	h_align;
+};
+
+/**
+ * struct hva_frameinfo - information about hva frame
+ *
+ * @flags:        flags about frame
+ * @fmt:          format of frame
+ * @width:        width of frame
+ * @height:       height of frame
+ * @crop:         cropping window due to encoder alignment constraints
+ *                (1920x1080@0,0 inside 1920x1088 encoded frame for ex.)
+ * @pixelaspect:  pixel aspect ratio of video (4/3, 5/4)
+ * @frame_width:  width of frame (encoder alignment constraint)
+ * @frame_height: height of frame (encoder alignment constraint)
+*/
+struct hva_frameinfo {
+	u32			flags;
+	struct hva_frame_fmt	fmt;
+	u32			width;
+	u32			height;
+	struct v4l2_rect	crop;
+	struct v4l2_fract	pixelaspect;
+	u32			frame_width;
+	u32			frame_height;
+};
+
+#define HVA_FRAMEINFO_FLAG_CROP		0x0001
+#define HVA_FRAMEINFO_FLAG_PIXELASPECT	0x0002
+
+/**
+ * struct hva_streaminfo - information about hva stream
+ *
+ * @flags         flags about stream
+ * @streamformat: fourcc code of compressed video format (H.264...)
+ * @width:        width of stream
+ * @height:       height of stream
+ * @dpb:          number of frames needed to encode a single frame
+ *                (e.g. H.264 dpb up to 16 in standard)
+ * @profile:      profile string
+ * @level:        level string
+ * @other:        other string information from codec
+ */
+struct hva_streaminfo {
+	u32	flags;
+	u32	streamformat;
+	u32	width;
+	u32	height;
+	u32	dpb;
+	u8	profile[32];
+	u8	level[32];
+	u8	other[32];
+};
+
+#define HVA_STREAMINFO_FLAG_OTHER	0x0001
+#define HVA_STREAMINFO_FLAG_H264	0x0002
+#define HVA_STREAMINFO_FLAG_VP8		0x0004
+
+/**
+ * struct hva_controls - hva controls set
+ *
+ * @bitrate_mode:  bitrate mode (constant bitrate or variable bitrate)
+ * @gop_size:      groupe of picture size
+ * @bitrate:       bitrate (in kbps)
+ * @aspect:        video aspect
+ * @profile:       H.264 profile
+ * @level:         H.264 level
+ * @entropy_mode:  H.264 entropy mode (CABAC or CVLC)
+ * @cpb_size:      coded picture buffer size (in kbps)
+ * @dct8x8:        transform mode 8x8 enable
+ * @qpmin:         minimum quantizer
+ * @qpmax:         maximum quantizer
+ * @vui_sar:       pixel aspect ratio enable
+ * @vui_sar_idc:   pixel aspect ratio identifier
+ * @sei_fp:        sei frame packing arrangement enable
+ * @sei_fp_type:   sei frame packing arrangement type
+ */
+struct hva_controls {
+	enum v4l2_mpeg_video_bitrate_mode			bitrate_mode;
+	u32							gop_size;
+	u32							bitrate;
+	enum v4l2_mpeg_video_aspect				aspect;
+	enum v4l2_mpeg_video_h264_profile			profile;
+	enum v4l2_mpeg_video_h264_level				level;
+	enum v4l2_mpeg_video_h264_entropy_mode			entropy_mode;
+	u32							cpb_size;
+	bool							dct8x8;
+	u32							qpmin;
+	u32							qpmax;
+	bool							vui_sar;
+	enum v4l2_mpeg_video_h264_vui_sar_idc			vui_sar_idc;
+	bool							sei_fp;
+	enum v4l2_mpeg_video_h264_sei_fp_arrangement_type	sei_fp_type;
+};
+
+/**
+ * struct hva_frame - hva frame
+ *
+ * @v4l2:     video buffer information for v4l2.
+ *            To be kept first and not to be wrote by driver.
+ *            Allows to get the hva_frame fields by just casting a vb2_buffer
+ *            with hva_frame struct. This is allowed through the use of
+ *            vb2 custom buffer mechanism, see @buf_struct_size of
+ *            struct vb2_queue in include/media/videobuf2-core.h
+ * @paddr:    physical address (for hardware)
+ * @vaddr:    virtual address (kernel can read/write)
+ * @prepared: true if vaddr/paddr are resolved
+ */
+struct hva_frame {
+	struct vb2_v4l2_buffer	v4l2;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	bool			prepared;
+};
+
+/**
+ * struct hva_stream - hva stream
+ *
+ * @v4l2:     video buffer information for v4l2.
+ *            To be kept first and not to be wrote by driver.
+ *            Allows to get the hva_stream fields by just casting a vb2_buffer
+ *            with hva_stream struct. This is allowed through the use of
+ *            vb2 custom buffer mechanism, see @buf_struct_size of
+ *            struct vb2_queue in include/media/videobuf2-core.h
+ * @list:     list element
+ * @paddr:    physical address (for hardware)
+ * @vaddr:    virtual address (kernel can read/write)
+ * @prepared: true if vaddr/paddr are resolved
+ * @payload:  number of bytes occupied by data in the buffer
+ */
+struct hva_stream {
+	struct vb2_v4l2_buffer	v4l2;
+	struct list_head	list;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	int			prepared;
+	unsigned int		payload;
+};
+
+/**
+ * struct hva_buffer - hva buffer
+ *
+ * @name:  name of requester
+ * @attrs: dma attributes
+ * @paddr: physical address (for hardware)
+ * @vaddr: virtual address (kernel can read/write)
+ * @size:  size of buffer
+ */
+struct hva_buffer {
+	const char		*name;
+	struct dma_attrs	attrs;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	u32			size;
+};
+
+struct hva_device;
+struct hva_encoder;
+
+/**
+ * struct hva_ctx - hva context
+ *
+ * @flags:          validity of streaminfo and frameinfo fields
+ * @fh:             v4l2 file handle
+ * @hva_dev:        the device this context applies to
+ * @client_id:      client identifier
+ * @q_frame:        v4l2 vb2 queue for frames, allocated by driver
+ *                  but managed by vb2 framework
+ * @q_stream:       v4l2 vb2 queue for streams, allocated by driver
+ *                  but managed by vb2 framework
+ * @name:           instance name (debug purpose)
+ * @list_stream:    list of streams queued
+ * @frame_num:      frame number
+ * @stream_num:     stream number
+ * @ctrl_handler:   v4l2 controls handler
+ * @ctrls:          hva controls set
+ * @time_per_frame: time per frame
+ * @streaminfo:     stream properties
+ * @frameinfo:      frame properties
+ * @encoder:        current encoder
+ * @num_frames:     number of frames received
+ * @num_streams:    number of streams produced
+ * @priv:           private codec context for this instance, allocated
+ *                  by encoder @open time.
+ * @sys_errors:     number of system errors (memory, resource, pm..)
+ * @encode_errors:  number of encoding errors (hw/driver errors)
+ * @frame_errors:   number of frame errors (format, size, header...)
+ * @hw_err:         true if hardware error detected
+ * @task:           hardware task descriptor
+ */
+struct hva_ctx {
+	u32				flags;
+	struct v4l2_fh			fh;
+	struct hva_device		*hva_dev;
+	u8				client_id;
+	struct vb2_queue		q_frame;
+	struct vb2_queue		q_stream;
+	char				name[100];
+	struct list_head		list_stream;
+	u32				frame_num;
+	u32				stream_num;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct hva_controls		ctrls;
+	struct v4l2_fract		time_per_frame;
+	struct hva_streaminfo		streaminfo;
+	struct hva_frameinfo		frameinfo;
+	struct hva_encoder		*encoder;
+	u32				num_frames;
+	u32				num_streams;
+	void				*priv;
+	u32				sys_errors;
+	u32				encode_errors;
+	u32				frame_errors;
+	bool				hw_err;
+	struct hva_buffer		*task;
+};
+
+#define HVA_FLAG_STREAMINFO 0x0001
+#define HVA_FLAG_FRAMEINFO 0x0002
+
+#define HVA_MAX_ENCODERS 30
+
+/**
+ * struct hva_device - abstraction for hva entity
+ *
+ * @v4l2_dev:        v4l2 device
+ * @vdev:            video device
+ * @pdev:            platform device
+ * @dev:             device
+ * @lock:            mutex used for critical sections & v4l2 ops serialization
+ * @instance_id:     instance identifier
+ * @alloc_ctx:       videobuf2 memory allocator context
+ * @contexts_list:   contexts list
+ * @regs:            register io memory access
+ * @regs_size:       register size
+ * @irq_its:         its interruption
+ * @irq_err:         error interruption
+ * @chip_id:         chipset identifier
+ * @protect_mutex:   mutex used to lock access of hardware
+ * @interrupt:       completion interrupt
+ * @clk:             hva clock
+ * @esram_addr:      esram address
+ * @esram_size:      esram size
+ * @sfl_reg:         status fifo level register value
+ * @sts_reg:         status register value
+ * @lmi_err_reg:     local memory interface error register value
+ * @emi_err_reg:     external memory interface error register value
+ * @hec_mif_err_reg: HEC memory interface error register value
+ * @encoders:        list of all encoders registered
+ * @nb_of_encoders:  number of encoders registered
+ * @nb_of_instances: number of instance
+ */
+struct hva_device {
+	struct v4l2_device		v4l2_dev;
+	struct video_device		*vdev;
+	struct platform_device		*pdev;
+	struct device			*dev;
+	/* mutex used for critical sections & v4l2 ops serialization */
+	struct mutex			lock;
+	int				instance_id;
+	struct vb2_alloc_ctx		*alloc_ctx;
+	struct hva_ctx			*contexts_list[MAX_CONTEXT];
+	void __iomem			*regs;
+	int				regs_size;
+	int				irq_its;
+	int				irq_err;
+	unsigned long int		chip_id;
+	/* mutex used to lock access of hardware */
+	struct mutex			protect_mutex;
+	struct completion		interrupt;
+	struct clk			*clk;
+	u32				esram_addr;
+	u32				esram_size;
+	u32				sfl_reg;
+	u32				sts_reg;
+	u32				lmi_err_reg;
+	u32				emi_err_reg;
+	u32				hec_mif_err_reg;
+	const struct hva_encoder	*encoders[HVA_MAX_ENCODERS];
+	u32				nb_of_encoders;
+	u32				nb_of_instances;
+};
+
+/**
+ * struct hva_encoder - hva encoder
+ *
+ * @name: encoder name
+ * @streamformat: fourcc code for compressed video format (H.264...)
+ * @pixelformat: fourcc code for uncompressed video format
+ * @max_width: maximum width of frame for this encoder
+ * @max_height: maximum height of frame for this encoder
+ * @open: open encoder
+ * @close: close encoder
+ * @encode: encode a frame (struct hva_frame) in a stream (struct hva_stream)
+ */
+
+struct hva_encoder {
+	const char *name;
+	u32 streamformat;
+	u32 pixelformat;
+	u32 max_width;
+	u32 max_height;
+	int (*open)(struct hva_ctx *ctx);
+	int (*close)(struct hva_ctx *ctx);
+	int (*encode)(struct hva_ctx *ctx, struct hva_frame *frame,
+		      struct hva_stream *stream);
+};
+
+static inline const char *profile_str(unsigned int p)
+{
+	switch (p) {
+	case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
+		return "baseline profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
+		return "main profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:
+		return "extended profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
+		return "high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10:
+		return "high 10 profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422:
+		return "high 422 profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE:
+		return "high 444 predictive profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA:
+		return "high 10 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA:
+		return "high 422 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA:
+		return "high 444 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA:
+		return "calvc 444 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE:
+		return "scalable baseline profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH:
+		return "scalable high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA:
+		return "scalable high intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH:
+		return "stereo high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH:
+		return "multiview high profile";
+	default:
+		return "unknown profile";
+	}
+}
+
+static inline const char *level_str(enum v4l2_mpeg_video_h264_level l)
+{
+	switch (l) {
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_0:
+		return "level 1.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1B:
+		return "level 1b";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_1:
+		return "level 1.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_2:
+		return "level 1.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_3:
+		return "level 1.3";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_0:
+		return "level 2.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_1:
+		return "level 2.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_2:
+		return "level 2.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_0:
+		return "level 3.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_1:
+		return "level 3.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_2:
+		return "level 3.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_0:
+		return "level 4.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_1:
+		return "level 4.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_2:
+		return "level 4.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_5_0:
+		return "level 5.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_5_1:
+		return "level 5.1";
+	default:
+		return "unknown level";
+	}
+}
+
+static inline const char *bitrate_mode_str(enum v4l2_mpeg_video_bitrate_mode m)
+{
+	switch (m) {
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
+		return "variable bitrate";
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
+		return "constant bitrate";
+	default:
+		return "unknown bitrate mode";
+	}
+}
+
+#endif /* HVA_H */
-- 
1.9.1

